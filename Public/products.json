[
    {
        "id": 1,
        "name": "Bornera Pcb 2 Pines (x10)",
        "price": "190",
        "quantity": 2,
        "images": [
            "Imagenes/1/1_1.png"
        ],
        "description": "Descripción Técnica:\n5.08-301-2P es un conector de bloque terminal de tornillo de 2 pines con un paso de 5mm, comúnmente utilizado en proyectos de electrónica para realizar conexiones seguras y desmontables entre componentes y placas de circuito impreso (PCB).\n\nEspecificaciones Técnicas:\nPaso (Pitch): 5mm\nNúmero de Pines: 2\nTipo de Conexión: Bloque terminal de tornillo\nTensión Máxima: 300V\nCorriente Máxima: 10A\nMaterial del Cuerpo: Poliamida (PA)\nMaterial del Contacto: Cobre con revestimiento de níquel\nTemperatura de Operación: -40°C a 105°C\n\nCaracterísticas:\nFácil Instalación: Los tornillos permiten una conexión firme y fácil de instalar.\nDesmontable: Las conexiones se pueden desmontar y volver a montar fácilmente, ideal para aplicaciones de prototipos y pruebas.\nSeguro: Proporciona una conexión segura y confiable, reduciendo el riesgo de desconexiones accidentales.\n\nAplicaciones:\nProyectos de Electrónica DIY: Ideal para proyectos de hobby y prototipos.\nAutomatización Industrial: Utilizado en conexiones de sensores y actuadores.\nInstrumentación: Conexiones en equipos de medida y control.\nDomótica: Conexiones en sistemas de control y automatización del hogar.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 2,
        "name": "Display Led 8 Bit Max7219",
        "price": "280",
        "quantity": 7,
        "images": [
            "Imagenes/2/2_1.png",
            "Imagenes/2/2_2.png",
            "Imagenes/2/2_3.png"
        ],
        "description": "Descripción Técnica:\n\nTipo de Display: 7 segmentos\nNúmero de Dígitos: 4\nControlador: TM1637\nVoltaje de Operación: 3.3V - 5V\nConsumo de Corriente: 80mA\nDimensiones: 12.8mm de altura del dígito\nInterfaz de Comunicación: 2 cables (CLK y DIO)\nCompatibilidad: Compatible con microcontroladores como Arduino, ESP8266, ESP32, y otros.\nCaracterísticas Adicionales:\nFácil de conectar y usar.\nBajo consumo de energía.\nAlta luminosidad y claridad.\nSoporte para mostrar números y algunos caracteres alfabéticos.\n\nAplicaciones:\n\nIdeal para proyectos donde se necesita mostrar números, como relojes, cronómetros, medidores, y cualquier aplicación que requiera visualización de datos numéricos de manera clara y eficiente.\n\nEste ejemplo muestra cómo conectar y controlar el display utilizando la biblioteca TM1637 para Arduino.\n\nConexiones:\nCLK (Clock): Pin 2 de Arduino\nDIO (Data In/Out): Pin 3 de Arduino\nVCC: 5V de Arduino\nGND: GND de Arduino",
        "code": "#include <TM1637Display.h>\n\n// Definir los pines de conexión\n#define CLK 2\n#define DIO 3\n\n// Crear una instancia del objeto display\nTM1637Display display(CLK, DIO);\n\nvoid setup() {\n  // Inicializar el display\n  display.setBrightness(0x0f); // Configurar el brillo (0x0f es el más brillante)\n}\n\nvoid loop() {\n  // Mostrar un número en el display\n  display.showNumberDec(1234); // Mostrar el número 1234\n\n  delay(2000); // Esperar 2 segundos\n\n  // Mostrar cada dígito individualmente\n  display.showNumberDecEx(5678, 0b01000000, true); // Mostrar 5678 con un punto decimal en el segundo dígito\n\n  delay(2000); // Esperar 2 segundos\n\n  // Mostrar un contador\n  for (int i = 0; i <= 9999; i++) {\n    display.showNumberDec(i); // Mostrar el número actual del contador\n    delay(100); // Esperar 100 milisegundos\n  }\n\n  delay(2000); // Esperar 2 segundos\n}",
        "datasheet": false
    },
    {
        "id": 5,
        "name": "ESP8266 en placa de desarrollo Micro USB",
        "price": "330",
        "quantity": 12,
        "images": [
            "Imagenes/5/5_1.png",
            "Imagenes/5/5_2.png",
            "Imagenes/5/5_3.png",
            "Imagenes/5/5_4.png"
        ],
        "description": "Resumen Técnico: ESP8266 NodeMCU\nEl ESP8266 NodeMCU es un módulo WiFi basado en el chip ESP8266 que permite agregar conectividad WiFi a proyectos de electrónica. Es ideal para aplicaciones de IoT (Internet of Things) debido a su tamaño compacto, bajo costo y capacidad de procesamiento.\n\nCaracterísticas:\nChip: ESP8266\nProcesador: Tensilica L106 a 80MHz\nMemoria: 32KB de memoria de instrucción, 80KB de memoria de usuario y 4MB de memoria flash\nConectividad: WiFi 802.11 b/g/n\nGPIOs: 11 pines GPIO (General Purpose Input/Output)\nProtocolos soportados: TCP/IP, HTTP, MQTT, etc.\nInterfaz: UART, SPI, I2C, PWM, ADC\nVoltaje de operación: 3.3V\nConsumo de energía: Modo normal: ~70mA, Modo de bajo consumo: <1mA\nAplicaciones:\nAutomatización del hogar\nProyectos de domótica\nDispositivos conectados a Internet\nSensores y actuadores remotos\nPrototipos de IoT\nCódigo de Ejemplo para ESP8266 NodeMCU\nA continuación se presenta un ejemplo de código para utilizar el ESP8266 NodeMCU para conectarse a una red WiFi y enviar datos a través de HTTP. En este ejemplo, se envían datos simulados de temperatura y humedad a un servidor web cada 10 segundos.",
        "code": "#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n\n// Configura los datos de tu red WiFi\nconst char* ssid = \"NOMBRE_DE_TU_RED\";\nconst char* password = \"CONTRASENA_DE_TU_RED\";\n\n// Configura la URL del servidor al que se enviarán los datos\nconst char* serverUrl = \"http://example.com/api/data\";\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n\n  Serial.print(\"Conectando a \");\n  Serial.print(ssid);\n\n  // Espera hasta que el ESP8266 se conecte a la red WiFi\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi conectado.\");\n  Serial.print(\"Dirección IP: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {\n  if (WiFi.status() == WL_CONNECTED) {\n    HTTPClient http;\n\n    // Simula datos de temperatura y humedad\n    float temperature = random(20, 30) + random(0, 99) / 100.0;\n    float humidity = random(40, 60) + random(0, 99) / 100.0;\n\n    // Crea la URL completa con los datos\n    String url = serverUrl;\n    url += \"?temperature=\" + String(temperature) + \"&humidity=\" + String(humidity);\n\n    http.begin(url);\n    int httpCode = http.GET();\n\n    if (httpCode > 0) {\n      String payload = http.getString();\n      Serial.println(\"Datos enviados correctamente\");\n      Serial.println(\"Respuesta del servidor: \" + payload);\n    } else {\n      Serial.println(\"Error al enviar los datos: \" + http.errorToString(httpCode));\n    }\n\n    http.end();\n  } else {\n    Serial.println(\"Error de conexión WiFi\");\n  }\n\n  delay(10000); // Espera 10 segundos antes de enviar los datos nuevamente\n}",
        "datasheet": false
    },
    {
        "id": 8,
        "name": "Diodo Rectificador 10a 1000v",
        "price": "190",
        "quantity": 9,
        "images": [
            "Imagenes/8/8_1.png",
            "Imagenes/8/8_2.png"
        ],
        "description": "Resumen Técnico: Diodo Rectificador 10A 1000V\nEl diodo rectificador de 10A 1000V es un componente semiconductor utilizado principalmente en aplicaciones de rectificación de corriente alterna a corriente continua. Este tipo de diodo es adecuado para manejar altas corrientes y voltajes elevados, lo que lo hace ideal para fuentes de alimentación y otros circuitos de potencia.\n\nCaracterísticas:\nCorriente Directa Máxima (IF): 10A\nVoltaje Inverso Máximo (VR): 1000V\nCaída de Tensión Directa (VF): Aproximadamente 1.1V a 10A\nTiempo de Recuperación Inversa (trr): 2μs\nCapacitancia: 200pF\nRango de Temperatura de Operación: -55°C a 150°C\nAplicaciones:\nFuentes de alimentación conmutadas\nRectificación en circuitos de alta corriente\nInversores y convertidores de frecuencia\nProtección contra inversión de polaridad\nAplicaciones industriales de alta potencia\nCódigo de Ejemplo para ESP32 utilizando Diodo Rectificador 10A 1000V\nA continuación se presenta un ejemplo de cómo utilizar el diodo rectificador de 10A 1000V en un circuito de rectificación con un ESP32 para monitorear el voltaje rectificado.",
        "code": "#define VOLTAGE_PIN 34  // Pin analógico para medir el voltaje rectificado\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(VOLTAGE_PIN, INPUT);\n}\n\nvoid loop() {\n  int sensorValue = analogRead(VOLTAGE_PIN);\n  float voltage = sensorValue * (3.3 / 4095.0) * 2; // Ajuste para el divisor de voltaje\n  Serial.print(\"Voltaje rectificado: \");\n  Serial.print(voltage);\n  Serial.println(\" V\");\n  delay(1000);\n}",
        "datasheet": true
    },
    {
        "id": 9,
        "name": "KBPC5010",
        "price": "170",
        "quantity": 8,
        "images": [
            "Imagenes/9/9_1.png",
            "Imagenes/9/9_2.png",
            "Imagenes/9/9_3.png"
        ],
        "description": "El puente rectificador KBPC5010 es un componente electrónico utilizado para convertir corriente alterna (AC) en corriente directa (DC). Es comúnmente utilizado en fuentes de alimentación y circuitos de rectificación de alta corriente.\n\nCaracterísticas:\nModelo: KBPC5010\nCorriente máxima: 50A\nVoltaje máximo inverso repetitivo (V_RRM): 1000V\nTipo de montaje: A través de orificio\nConfiguración: Monofásico\nTemperatura de operación: -55°C a +150°C\nAplicaciones:\nFuentes de alimentación\nEquipos de telecomunicaciones\nRectificación de señal\nConvertidores de energía\nElectrónica de potencia\nCódigo de Ejemplo para ESP32\nA continuación se presenta un ejemplo de código para utilizar un ESP32 en un circuito de rectificación, controlando un puente rectificador como parte de una fuente de alimentación. El código incluye la medición de voltaje y la visualización de datos en una pantalla TFT.\n\nConexiones ESP32:\nAIN: Pin GPIO34 (Lectura del voltaje rectificado)\nPantalla TFT: Mismos pines que en el ejemplo anterior",
        "code": "#include <Adafruit_GFX.h>    // Biblioteca de gráficos de Adafruit\n#include <Adafruit_ST7735.h> // Biblioteca para el controlador ST7735\n#include <SPI.h>\n\n// Definir pines de conexión de la pantalla\n#define TFT_CS     5\n#define TFT_RST    4\n#define TFT_DC     2\n\n// Crear una instancia del objeto ST7735\nAdafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Inicializar la pantalla\n  tft.initR(INITR_BLACKTAB);\n  tft.setRotation(1); // Opcional: cambiar la orientación de la pantalla\n  tft.fillScreen(ST77XX_BLACK);\n\n  // Configurar el color del texto y tamaño de la fuente\n  tft.setTextColor(ST77XX_WHITE);\n  tft.setTextSize(2);\n\n  // Mostrar un mensaje de inicio\n  tft.setCursor(10, 10);\n  tft.println(\"Lectura de Voltaje\");\n}\n\nvoid loop() {\n  // Leer el voltaje del puente rectificador\n  int analogValue = analogRead(34); // Leer el pin analógico GPIO34\n  float voltage = analogValue * (3.3 / 4095.0) * (1000.0 / 100.0); // Ajustar según el divisor de voltaje\n\n  // Mostrar el voltaje en la pantalla TFT\n  tft.fillRect(10, 40, 200, 30, ST77XX_BLACK); // Limpiar área\n  tft.setCursor(10, 40);\n  tft.print(\"V: \");\n  tft.print(voltage);\n  tft.println(\" V\");\n\n  // Enviar el voltaje a través del puerto serie\n  Serial.print(\"Voltaje: \");\n  Serial.print(voltage);\n  Serial.println(\" V\");\n\n  delay(1000); // Esperar 1 segundo antes de la próxima lectura\n}",
        "datasheet": false
    },
    {
        "id": 10,
        "name": "Triac BTA41-600b",
        "price": "150",
        "quantity": 49,
        "images": [
            "Imagenes/10/10_1.png",
            "Imagenes/10/10_2.jpg",
            "Imagenes/10/10_3.jpg",
            "Imagenes/10/10_4.jpg"
        ],
        "description": "El BTA4-600B es un triac (Triodo para Corriente Alterna) utilizado en el control de potencia de corriente alterna (CA). Es un componente semiconductor que puede conmutar y controlar corrientes altas, lo que lo hace ideal para aplicaciones como dimmers de luz, controladores de velocidad de motores, y reguladores de calefacción.\n\nEspecificaciones Técnicas:\nVoltaje Máximo de Repetición de Pico Inverso (VDRM): 600V\nCorriente Media (IT(RMS)): 4A\nCorriente de Puerta (IGT): 35mA\nVoltaje de Encendido de Puerta (VGT): 1.3V\nTemperatura de Operación: -40°C a 125°C\nEncapsulado: TO-220AB\nTensión Máxima de Pico No Repetitiva (VDSM): 800V\nCaracterísticas:\nAlta Capacidad de Corriente: Puede manejar corrientes de hasta 4A.\nControl de Puerta Sensible: Requiere una corriente de puerta relativamente baja para activarse.\nEncapsulado TO-220AB: Ofrece buena disipación de calor y facilidad de montaje.\nDurabilidad: Operación fiable en un rango amplio de temperaturas.\nAplicaciones:\nControl de Iluminación: Dimmers para luces incandescentes o de halógeno.\nControl de Motores: Variadores de velocidad para pequeños motores de corriente alterna.\nRegulación de Temperatura: Controladores de calefacción en electrodomésticos.\nConmutación de Carga: En aplicaciones industriales para conmutar cargas resistivas o inductivas.",
        "code": "",
        "datasheet": true
    },
    {
        "id": 11,
        "name": "Chip Attiny85-20pu",
        "price": "350",
        "quantity": 7,
        "images": [
            "Imagenes/11/11_1.png",
            "Imagenes/11/11_2.png",
            "Imagenes/11/11_3.png"
        ],
        "description": "El ATtiny85-20PU es un microcontrolador de la serie ATtiny de Atmel, ahora parte de Microchip Technology. Es conocido por su pequeño tamaño y su capacidad para realizar tareas simples de automatización y control en proyectos de electrónica. A continuación se presenta un resumen técnico de sus características y especificaciones:\n\nResumen Técnico del ATtiny85-20PU\nEspecificaciones Generales:\nArquitectura: AVR de 8 bits\nMemoria Flash: 8 KB para almacenamiento de programas\nMemoria SRAM: 512 bytes\nMemoria EEPROM: 512 bytes\nVelocidad del Reloj: Hasta 20 MHz con un cristal externo\nVoltaje de Operación: 2.7V a 5.5V\nEncapsulado: PDIP de 8 pines\nCaracterísticas Principales:\nPuertos de Entrada/Salida (I/O):\n\n6 pines de I/O programables\nPines compatibles con funciones adicionales como PWM, ADC, y comunicaciones en serie\nPeriféricos Integrados:\n\n1 ADC de 10 bits con 4 canales\n2 temporizadores de 8 bits\n1 temporizador de 16 bits\nComunicación en serie (SPI, I2C, UART)\nModos de Ahorro de Energía:\n\nModo inactivo\nModo de ahorro de energía\nModo de apagado\nModo de reserva\nCaracterísticas de Autoprogramación:\n\nCapacidad de programar la memoria Flash internamente\nSoporte para arranque rápido y código de arranque seguro\nReloj Interno:\n\nOscilador interno calibrado de 8 MHz\nAplicaciones Típicas:\nAutomatización y control en sistemas embebidos\nProyectos de bricolaje y electrónica de hobby\nSistemas de sensores y actuadores\nElectrónica portátil y dispositivos de bajo consumo\nEjemplo de Circuito:\nUn ejemplo de cómo utilizar el ATtiny85-20PU en un circuito simple que enciende y apaga un LED utilizando un interruptor.\n\nMateriales Necesarios:\nMicrocontrolador: ATtiny85-20PU\nResistencias: 220 ohmios, 10k ohmios\nLED\nInterruptor (Push Button)\nFuente de alimentación: 5V\nEsquema del Circuito:\nConexión del LED:\n\nConectar el ánodo del LED a un pin de salida del ATtiny85 (por ejemplo, PB0).\nConectar el cátodo del LED a una resistencia de 220 ohmios, y la otra terminal de la resistencia a GND.\nConexión del Interruptor:\n\nConectar un terminal del interruptor a Vcc (5V).\nConectar el otro terminal del interruptor a un pin de entrada del ATtiny85 (por ejemplo, PB1) y a una resistencia de 10k ohmios conectada a GND (pull-down resistor).",
        "code": "#lenguaje C\n#include <avr/io.h>\n#include <util/delay.h>\n\n#define LED_PIN PB0\n#define BUTTON_PIN PB1\n\nvoid setup() {\n  // Configurar LED_PIN como salida\n  DDRB |= (1 << LED_PIN);\n  \n  // Configurar BUTTON_PIN como entrada\n  DDRB &= ~(1 << BUTTON_PIN);\n  // Activar resistencia pull-up interna para BUTTON_PIN\n  PORTB |= (1 << BUTTON_PIN);\n}\n\nvoid loop() {\n  // Leer el estado del botón\n  if (PINB & (1 << BUTTON_PIN)) {\n    // Si el botón está presionado, encender el LED\n    PORTB |= (1 << LED_PIN);\n  } else {\n    // Si el botón no está presionado, apagar el LED\n    PORTB &= ~(1 << LED_PIN);\n  }\n  \n  // Pequeño retardo para debounce\n  _delay_ms(50);\n}\n\nint main(void) {\n  setup();\n  while (1) {\n    loop();\n  }\n}",
        "datasheet": true
    },
    {
        "id": 12,
        "name": "Programador Universal Usb Avr Isp (con Adaptador)",
        "price": "350",
        "quantity": 9,
        "images": [
            "Imagenes/12/12_1.png",
            "Imagenes/12/12_2.png"
        ],
        "description": "El Programador Universal USB AVR ISP es una herramienta esencial para programar microcontroladores AVR de Atmel, como el ATtiny y el ATmega, entre otros. Este dispositivo permite cargar programas en la memoria flash de los microcontroladores a través del protocolo ISP (In-System Programming). A continuación se presenta un resumen técnico y guía de uso para este programador, especialmente con el adaptador.\n\nResumen Técnico del Programador Universal USB AVR ISP\nEspecificaciones Generales:\nCompatibilidad:\n\nCompatible con la mayoría de los microcontroladores AVR, incluyendo ATmega y ATtiny.\nSoporte para chips con interfaces ISP.\nConexión:\n\nInterfaz USB para conexión con la computadora.\nConector ISP de 6 pines y 10 pines para conexión con el microcontrolador.\nProtocolos Soportados:\n\nISP (In-System Programming).\nVelocidad de Programación:\n\nConfigurable a diferentes velocidades para compatibilidad con diversos chips y configuraciones.\nSoporte de Software:\n\nCompatible con herramientas de desarrollo como Atmel Studio y AVRDude.\nDrivers disponibles para Windows, Mac y Linux.\nAlimentación:\n\nAlimentado a través del puerto USB.\nPuede alimentar el microcontrolador durante la programación (5V).\nComponentes Incluidos:\nProgramador USB AVR ISP.\nCables de conexión: Usualmente incluyen cables de 6 y 10 pines.\nAdaptador: Permite la conexión a diferentes tipos de microcontroladores y placas de desarrollo.\nGuía de Uso:\nPaso 1: Instalación de Drivers\nDescargar Drivers:\n\nAsegúrate de descargar los drivers correctos para tu sistema operativo desde el sitio web del fabricante o la fuente del programador.\nInstalar Drivers:\n\nSigue las instrucciones proporcionadas con los drivers para instalarlos correctamente en tu computadora.\nPaso 2: Conexión del Programador\nConectar a la Computadora:\n\nConecta el programador al puerto USB de tu computadora.\nConectar al Microcontrolador:\n\nUtiliza el adaptador y los cables de conexión para conectar el programador a la interfaz ISP del microcontrolador.\nAsegúrate de alinear correctamente los pines de VCC, GND, MISO, MOSI, SCK y RESET.\nPaso 3: Programación del Microcontrolador\nSoftware de Programación:\n\nAbre tu software de programación preferido, como Atmel Studio o AVRDude.\nConfiguración del Software:\n\nConfigura el software para utilizar el programador USB AVR ISP.\nSelecciona el modelo del microcontrolador que estás programando.\nAjusta la velocidad de programación si es necesario.\nCargar el Programa:\n\nCompila el código que deseas cargar en el microcontrolador.\nUtiliza el software de programación para cargar el código compilado en la memoria flash del microcontrolador.\nVerificar la Programación:\n\nDespués de la programación, verifica que el código haya sido cargado correctamente ejecutando alguna prueba o utilizando las herramientas de verificación del software.\nEjemplo de Uso con AVRDude:\nSi estás utilizando AVRDude como herramienta de programación, aquí hay un ejemplo de cómo puedes programar un ATtiny85 con un archivo .hex:\n\nConectar el Programador y el Microcontrolador:\n\nConecta el programador USB AVR ISP a la computadora y al ATtiny85 usando el adaptador adecuado.\nComando AVRDude:\n\nAbre una terminal o línea de comandos en tu computadora.\n\nUtiliza el siguiente comando para programar el ATtiny85:\n\nsh\nCopiar código\navrdude -c usbasp -p t85 -U flash:w:tu_archivo.hex:i\nDonde:\n\n-c usbasp: Especifica el tipo de programador (en este caso, usbasp).\n-p t85: Especifica el tipo de microcontrolador (en este caso, ATtiny85).\n-U flash:w:tu_archivo.hex:i: Especifica la operación de escritura en la memoria flash con el archivo .hex.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 14,
        "name": "Disipador De Calor De Aluminio, 25x24x16mm (4 Unidades)",
        "price": "220",
        "quantity": 3,
        "images": [
            "Imagenes/14/14_1.png",
            "Imagenes/14/14_2.png",
            "Imagenes/14/14_3.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 16,
        "name": "Diodo Db3 Disparador 20 Piezas ",
        "price": "150",
        "quantity": 10,
        "images": [
            "Imagenes/16/16_1.jpg",
            "Imagenes/16/16_2.jpg",
            "Imagenes/16/16_3.jpg",
            "Imagenes/16/16_4.jpg"
        ],
        "description": "Descripción General\nEl DB3 es un diodo de disparo bilateral, también conocido como diodo DIAC, utilizado principalmente en circuitos de control de corriente alterna (CA) y aplicaciones de disparo de triac. Es un componente semiconductor que permite el paso de la corriente en ambas direcciones cuando se alcanza un voltaje de disparo específico, facilitando el control de dispositivos de potencia.\n\nCaracterísticas Técnicas\nTensión de Disparo: 28V a 36V.\nCorriente de Disparo: Típicamente alrededor de 50μA.\nCapacidad de Disparo: Permite un disparo fiable y repetible en ambos sentidos de la corriente.\nTemperatura de Funcionamiento: -40°C a +125°C.\nEncapsulado: Generalmente en TO-92 o DO-35.\nAplicaciones\nDisparo de Triacs: Usado en aplicaciones donde se requiere el control de fase de triacs, como en atenuadores de luz, controladores de velocidad de motores, y reguladores de calentadores.\nControl de CA: Empleado en circuitos de control de corriente alterna para aplicaciones industriales y domésticas.\nEncendido de Circuitos: Utilizado en circuitos que requieren encendido y apagado controlado de dispositivos de potencia.\nVentajas\nSimplicidad: Facilita el diseño de circuitos de control de potencia con un número reducido de componentes.\nConfiabilidad: Proporciona un disparo repetible y fiable, mejorando la eficiencia del circuito de control.\nBilateralidad: Capacidad de conducir corriente en ambas direcciones, lo que lo hace adecuado para aplicaciones de CA.\nEjemplo de Uso en un Circuito\nEn un atenuador de luz, el DB3 se utiliza para disparar un triac, controlando así la cantidad de energía que se suministra a una carga (por ejemplo, una lámpara). El circuito típico incluye un potenciómetro para ajustar el punto de disparo del triac y, por lo tanto, el brillo de la lámpara.",
        "code": "",
        "datasheet": true
    },
    {
        "id": 19,
        "name": "Placa Expansión  Esp32. Nuevo Modelo.",
        "price": "380",
        "quantity": 8,
        "images": [
            "Imagenes/19/19_1.png"
        ],
        "description": "Resumen Técnico\nPlaca de Expansión ESP32\n\nDescripción:\nLa Placa de Expansión ESP32 está diseñada para facilitar el desarrollo de proyectos con el microcontrolador ESP32, proporcionando una interfaz amigable para conectar sensores, actuadores y otros periféricos.\n\nEspecificaciones Técnicas:\nCompatibilidad:\n\nCompatible con ESP32 (38 Pines).\nConectividad:\n\nPines de entrada/salida digital: 38\nPines de alimentación: 5V, 3.3V y GND\nCaracterísticas Eléctricas:\n\nVoltaje de operación: 5V y 3.3V\nConector de alimentación: DC 6.5-16V\nComponentes Integrados:\n\nRegulador de voltaje: 5V y 3.3V\nConector micro USB para programación y alimentación\nPines de expansión claramente etiquetados para facilitar el uso\nDimensiones:\n\nLongitud: 100 mm\nAncho: 70 mm\nUsos Comunes:\nDesarrollo de Prototipos: Ideal para proyectos que requieren múltiples conexiones y facilidad de acceso a todos los pines del ESP32.\nProyectos de IoT: Adecuada para aplicaciones de Internet de las Cosas (IoT) debido a la capacidad del ESP32 para conectarse a Wi-Fi y Bluetooth.\nEducación: Herramienta útil para enseñanza y aprendizaje de electrónica y programación con microcontroladores.\nVentajas:\nFacilidad de Uso: Pines claramente etiquetados y organizados para un acceso rápido y sencillo.\nVersatilidad: Compatible con una amplia gama de sensores y módulos.\nEstabilidad: Regulador de voltaje integrado para una alimentación estable.\n\nCódigo de Ejemplo (ESP32):\nPara demostrar la aplicación de la Placa de Expansión ESP32, aquí hay un simple ejemplo de código que utiliza un sensor de temperatura DHT11:",
        "code": "#include \"DHT.h\"\n\n#define DHTPIN 4     // Pin donde se conecta el sensor DHT11\n#define DHTTYPE DHT11   // Definir el tipo de sensor DHT11\n\nDHT dht(DHTPIN, DHTTYPE);\n\nvoid setup() {\n  Serial.begin(115200);\n  dht.begin();\n}\n\nvoid loop() {\n  // Esperar entre lecturas\n  delay(2000);\n\n  // Leer la humedad\n  float h = dht.readHumidity();\n  // Leer la temperatura como Celsius\n  float t = dht.readTemperature();\n\n  // Comprobar si alguna lectura falló y salir de la función early\n  if (isnan(h) || isnan(t)) {\n    Serial.println(\"Fallo en la lectura del sensor DHT11!\");\n    return;\n  }\n\n  // Mostrar las lecturas en el monitor serie\n  Serial.print(\"Humedad: \");\n  Serial.print(h);\n  Serial.print(\" %\\t\");\n  Serial.print(\"Temperatura: \");\n  Serial.print(t);\n  Serial.println(\" *C \");\n}",
        "datasheet": false
    },
    {
        "id": 20,
        "name": "Módulo De Pantalla Led Tm1637 Para Arduino, 7 Segmentos, 4 B",
        "price": "160",
        "quantity": 5,
        "images": [
            "Imagenes/20/20_1.png",
            "Imagenes/20/20_2.png",
            "Imagenes/20/20_3.png",
            "Imagenes/20/20_4.png",
            "Imagenes/20/20_5.png",
            "Imagenes/20/20_6.png",
            "Imagenes/20/20_7.png"
        ],
        "description": "Resumen Técnico:\nModelo: TM1637\nSegmentos: 7 segmentos, 4 dígitos\nTensión de trabajo: 3.3V - 5V\nInterfaz: 2 pines (CLK y DIO)\nTamaño de la pantalla: 0.36 pulgadas\nDimensiones: 42mm x 24mm\nFunciones: Puede mostrar números del 0 al 9, algunas letras, y ciertos caracteres especiales.\nAplicaciones: Relojes, temporizadores, contadores, visualización de datos en tiempo real.",
        "code": "#include <Arduino.h>\n#include <TM1637Display.h>\n\n// Definimos los pines de conexión\n#define CLK 22\n#define DIO 21\n\n// Inicializamos el display\nTM1637Display display(CLK, DIO);\n\nvoid setup() {\n  // Configuramos el brillo del display (rango de 0 a 7)\n  display.setBrightness(0x0f);\n\n  // Mostramos un número de ejemplo (1234)\n  display.showNumberDec(1234);\n}\n\nvoid loop() {\n  // Aquí puedes añadir el código que desees para actualizar el display\n  // Ejemplo de contador\n  for (int i = 0; i < 10000; i++) {\n    display.showNumberDec(i);\n    delay(1000);  // Espera de 1 segundo entre cada incremento\n  }\n}",
        "datasheet": false
    },
    {
        "id": 21,
        "name": "Interruptor Mosfet (x2) De Alta Potencia (400w)",
        "price": "250",
        "quantity": 1,
        "images": [
            "Imagenes/21/21_1.png",
            "Imagenes/21/21_2.png",
            "Imagenes/21/21_3.png"
        ],
        "description": "Características Principales:\nModelo: Interruptor Mosfet de Alta Potencia (Dual MOS driver)\nCorriente: 15A\nPotencia: 400W\nVoltaje de Operación: 5V a 36V\nAplicaciones: Control de alta potencia, control de motores, control de lámparas de alta potencia, control de dispositivos de calefacción, etc.\nDescripción:\nEl interruptor Mosfet de alta potencia utiliza dos MOSFET para proporcionar un control de alta corriente y alta potencia. Este módulo es ideal para aplicaciones que requieren un control eficiente y de alta potencia, como motores eléctricos, lámparas de alta potencia y dispositivos de calefacción. El diseño del módulo permite una fácil integración en proyectos electrónicos, proporcionando una solución confiable para el control de dispositivos de alta corriente.\n\nCódigo de Ejemplo para ESP32:\nEste código de ejemplo muestra cómo controlar el interruptor Mosfet utilizando un ESP32.",
        "code": "#define MOSFET_PIN 5  // Definir el pin conectado al interruptor Mosfet\n\nvoid setup() {\n  pinMode(MOSFET_PIN, OUTPUT);  // Configurar el pin como salida\n}\n\nvoid loop() {\n  digitalWrite(MOSFET_PIN, HIGH);  // Encender el interruptor Mosfet\n  delay(1000);                     // Esperar 1 segundo\n  digitalWrite(MOSFET_PIN, LOW);   // Apagar el interruptor Mosfet\n  delay(1000);                     // Esperar 1 segundo\n}",
        "datasheet": false
    },
    {
        "id": 22,
        "name": "Módulo Usb A Ttl Cp2102 Con Cables Dupont",
        "price": "380",
        "quantity": 17,
        "images": [
            "Imagenes/22/22_1.jpg",
            "Imagenes/22/22_2.png",
            "Imagenes/22/22_3.jpg",
            "Imagenes/22/22_4.png"
        ],
        "description": "Cables dupont H-H de 20cm\n\nCaracterísticas del CP2102\nInterfaz USB 2.0 Full-Speed: Compatible con cualquier puerto USB estándar.\n\nInterfaz UART: Proporciona señales de transmisión y recepción (TX y RX) para la comunicación serial.\n\nBaud Rate: Soporta una amplia gama de velocidades de transmisión, desde 300 bps hasta 1 Mbps.\nAlimentación: Puede ser alimentado directamente desde el puerto USB.\n\nControl de flujo: Soporta control de flujo por hardware (RTS/CTS) y por software (XON/XOFF).\n\nDrivers: Compatible con Windows, Mac y Linux, con controladores fácilmente disponibles en el sitio web de Silicon Labs.\n\nUsos comunes\nProgramación de microcontroladores: Muy utilizado para la programación y depuración de microcontroladores y otros dispositivos embebidos.\n\nInterfaz serial para dispositivos embebidos: Ideal para agregar una interfaz USB a dispositivos que solo tienen una interfaz serial.\nProyectos de electrónica: Utilizado en una variedad de proyectos de electrónica y desarrollo de prototipos donde se necesita una interfaz serial confiable.\n\nConexión y uso\nConexión: Conecta el adaptador CP2102 a tu computadora mediante un cable USB. Los pines TX y RX del adaptador se conectan a los pines RX y TX del dispositivo con el que deseas comunicarte, respectivamente. También puedes conectar los pines de control de flujo si tu aplicación lo requiere.\n\nConfiguración: Una vez conectado, instala los controladores necesarios desde el sitio web de Silicon Labs. Después de la instalación, el adaptador aparecerá como un puerto COM en tu sistema operativo, que puedes usar con cualquier software de terminal serial.",
        "code": "# Codigo .py para comunicarse \n#con dispositivo serie\nimport serial\nimport time\n\n# Configuración del puerto serie\nport = '/dev/ttyUSB0'  # Cambia esto al puerto adecuado en tu sistema\nbaud_rate = 9600       # Configura la velocidad de transmisión\n\ntry:\n    # Abre la conexión serie\n    ser = serial.Serial(port, baud_rate, timeout=1)\n    print(f\"Conectado al puerto {port} a {baud_rate} baudios.\")\n\n    # Espera a que el dispositivo esté listo\n    time.sleep(2)\n\n    # Envía un comando al dispositivo\n    command = 'AT\\r\n'\n    ser.write(command.encode())\n    print(f\"Enviado: {command.strip()}\")\n\n    # Lee la respuesta del dispositivo\n    response = ser.read(ser.in_waiting or 1).decode()\n    print(f\"Respuesta: {response}\")\n\n    # Cierra la conexión\n    ser.close()\n    print(\"Conexión cerrada.\")\n\nexcept serial.SerialException as e:\n    print(f\"Error al abrir la conexión: {e}\")",
        "datasheet": false
    },
    {
        "id": 24,
        "name": "Conversor Serie--bluetooth Jdy-30",
        "price": "450",
        "quantity": 3,
        "images": [
            "Imagenes/24/24_1.png"
        ],
        "description": "Características Principales:\nModelo: JDY-30\nVoltaje de Operación: 3.6V a 6V\nInterfaz: UART (TXD, RXD)\nCompatibilidad: Compatible con módulos Bluetooth 2.0/3.0/4.0\nRango de Transmisión: Hasta 10 metros sin obstáculos\nVelocidad de Transmisión: 4800 bps a 1382400 bps\nAplicaciones: Comunicación inalámbrica en proyectos Arduino, ESP32, control remoto, transmisión de datos, etc.\nDescripción:\nEl módulo JDY-30 es un conversor serie a Bluetooth que permite la comunicación inalámbrica entre dispositivos. Este módulo es fácil de integrar en proyectos electrónicos y es compatible con una amplia gama de microcontroladores, incluyendo Arduino y ESP32. El JDY-30 soporta múltiples velocidades de transmisión y puede operar en un rango de voltaje amplio, lo que lo hace ideal para aplicaciones diversas, desde control remoto hasta transmisión de datos.\n\nCódigo de Ejemplo para ESP32:\nEste código de ejemplo muestra cómo configurar el ESP32 para comunicarse con el módulo JDY-30 utilizando UART.",
        "code": "#include <HardwareSerial.h>\n\nHardwareSerial MySerial(1);  // Utiliza UART1 del ESP32\n\nvoid setup() {\n  Serial.begin(115200);       // Inicializa la comunicación serial con el monitor serial\n  MySerial.begin(9600, SERIAL_8N1, 16, 17);  // Configura UART1 con TX en GPIO16 y RX en GPIO17\n\n  Serial.println(\"Iniciando comunicación con JDY-30...\");\n}\n\nvoid loop() {\n  if (MySerial.available()) {        // Si hay datos disponibles en el JDY-30\n    String data = MySerial.readString();  // Lee los datos recibidos\n    Serial.print(\"Recibido: \");      // Imprime los datos en el monitor serial\n    Serial.println(data);\n  }\n\n  if (Serial.available()) {         // Si hay datos disponibles en el monitor serial\n    String data = Serial.readString();  // Lee los datos recibidos\n    MySerial.print(data);            // Envía los datos al JDY-30\n  }\n}",
        "datasheet": false
    },
    {
        "id": 25,
        "name": "Diodo Rectificador M7 1n4007 Smd 1a 100 V. (20 Unidades)",
        "price": "120",
        "quantity": 2,
        "images": [
            "Imagenes/25/25_1.png"
        ],
        "description": "Características Principales:\nModelo: 1N4007 (SMD - M7)\nCorriente Máxima: 1A\nVoltaje Inverso Máximo: 1000V\nCaída de Voltaje Directo: 1.1V a 1A\nTipo de Montaje: Superficie (SMD)\nPaquete: DO-214AC (SMA)\nTemperatura de Operación: -65°C a +175°C\nAplicaciones: Rectificación de corriente, protección contra sobretensiones, aplicaciones de potencia, etc.\nDescripción:\nEl diodo rectificador 1N4007 en encapsulado SMD (M7) es un componente clave en aplicaciones de rectificación de corriente en fuentes de alimentación y otros circuitos electrónicos. Capaz de soportar voltajes inversos de hasta 1000V y corrientes de hasta 1A, este diodo es ideal para una amplia gama de aplicaciones. Su paquete SMD permite un montaje eficiente en placas de circuito impreso de alta densidad.",
        "code": "",
        "datasheet": true
    },
    {
        "id": 26,
        "name": "Lámpara Led Indoor 200w Reales. Dimerizable. Luz Combinada!",
        "price": "5200",
        "quantity": 1,
        "images": [],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 28,
        "name": "Sensor De Hall 49e (bici Eléctrica) 5 Unidades",
        "price": "160",
        "quantity": 15,
        "images": [
            "Imagenes/28/28_1.jpg",
            "Imagenes/28/28_2.jpg",
            "Imagenes/28/28_3.jpg",
            "Imagenes/28/28_4.jpg"
        ],
        "description": "El sensor Hall 49E es un dispositivo de efecto Hall que se utiliza para detectar la presencia de un campo magnético. Este sensor es ampliamente utilizado en aplicaciones de detección de velocidad, posición y corriente, así como en conmutadores sin contacto. A continuación se presenta un resumen técnico de sus características y especificaciones:\n\nCaracterísticas Principales\nTipo de Sensor: Sensor de efecto Hall lineal.\nRango de Operación de Campo Magnético: ±900 Gauss.\nSalida: Analógica.\nVoltaje de Operación: 4.5V a 6V.\nCorriente de Operación: 8mA (típica).\nSensibilidad: 1.4 mV/Gauss (típica).\nTemperatura de Operación: -40°C a +85°C.\nEmpaque: TO-92.\nEspecificaciones Eléctricas\nVoltaje de Alimentación (Vcc): 4.5V a 6V.\nCorriente de Consumo: 8mA.\nSalida de Voltaje en Condiciones Normales: Aproximadamente la mitad del voltaje de alimentación (Vcc/2).\nSensibilidad de Salida: Aproximadamente 1.4 mV/Gauss.\nAplicaciones Comunes\nDetección de Velocidad: En aplicaciones como tacómetros y velocímetros.\nDetección de Posición: Para identificar la posición de objetos en movimiento.\nDetección de Corriente: Usado en medidores de corriente sin contacto.\nConmutadores Sin Contacto: Para reemplazar interruptores mecánicos en diversas aplicaciones.\nSistemas de Encendido de Motores: Para detectar la posición del cigüeñal o el árbol de levas.\nVentajas\nAlta Sensibilidad: Permite detectar campos magnéticos muy débiles.\nSalida Lineal: Proporciona una salida analógica proporcional al campo magnético detectado.\nBajo Consumo de Energía: Ideal para aplicaciones de bajo consumo.\nOperación a Baja Tensión: Compatible con la mayoría de los sistemas electrónicos.\nFiabilidad y Durabilidad: Sin partes mecánicas que se desgasten.\nEsquema de Conexión\nEl sensor Hall 49E tiene tres pines:\n\nVcc: Voltaje de alimentación (4.5V a 6V).\nGND: Tierra.\nOUT: Salida analógica.",
        "code": "",
        "datasheet": true
    },
    {
        "id": 29,
        "name": "Led Cob YXO 50w, Dual Spectrum",
        "price": "380",
        "quantity": 47,
        "images": [
            "Imagenes/29/29_1.png",
            "Imagenes/29/29_2.png",
            "Imagenes/29/29_3.png",
            "Imagenes/29/29_4.png",
            "Imagenes/29/29_5.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 30,
        "name": "Esp32 Wifi Con Placa De Expansión último Modelo",
        "price": "990",
        "quantity": 8,
        "images": [
            "Imagenes/30/30_1.jpg",
            "Imagenes/30/30_2.jpg",
            "Imagenes/30/30_3.jpg"
        ],
        "description": "Gran Oportunidad para los amantes de la electrónica. Con la placa ESP32 de 38 pinos podrás hacer cualquier proyecto de microprocesadores sumándole la capacidad integrada de comunicación WIFI y/o bluetooth. Una joyita que cada vez está siendo más usada por grandes firmas. Junto con la placa viene su SHIELD para olvidarte del protoboard.",
        "code": "#include <WiFi.h>\n\n// Replace these with your WiFi network settings\nconst char* ssid = \"your_SSID\";\nconst char* password = \"your_PASSWORD\";\n\nvoid setup() {\n  // Start the Serial communication\n  Serial.begin(115200);\n  delay(10);\n\n  // Start connecting to the WiFi network\n  Serial.println();\n  Serial.println(\"Connecting to WiFi...\");\n  WiFi.begin(ssid, password);\n\n  // Wait until the ESP32 is connected to the WiFi network\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n\n  // Print the ESP32's IP address\n  Serial.println();\n  Serial.println(\"Connected to WiFi network!\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {\n  // Nothing here\n}",
        "datasheet": false
    },
    {
        "id": 31,
        "name": "Cable Usb A Micro, Alta Calidad, Tipo A. 0.3m",
        "price": "130",
        "quantity": 6,
        "images": [
            "Imagenes/31/31_1.png",
            "Imagenes/31/31_2.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 32,
        "name": "Módulo De Fuente De Alimentación Usb",
        "price": "270",
        "quantity": 9,
        "images": [
            "Imagenes/32/32_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 33,
        "name": "Sensor De Distancia Ultrasónico X2 (compatible Arduino)",
        "price": "280",
        "quantity": 2,
        "images": [
            "Imagenes/33/33_1.png",
            "Imagenes/33/33_2.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 35,
        "name": "Sensor Capacitivo De Humedad Del Suelo",
        "price": "180",
        "quantity": 2,
        "images": [
            "Imagenes/35/35_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 36,
        "name": "Adaptador Para Esp32 38pinos (ver Nota)",
        "price": "350",
        "quantity": 1,
        "images": [
            "Imagenes/36/36_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 37,
        "name": "Sensor De Luz Lm393 Arduino",
        "price": "130",
        "quantity": 9,
        "images": [
            "Imagenes/37/37_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 38,
        "name": "Sensor De Humedad Tierra (alta Precisión) Arduino",
        "price": "420",
        "quantity": 20,
        "images": [
            "Imagenes/38/38_1.png",
            "Imagenes/38/38_2.png",
            "Imagenes/38/38_3.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 40,
        "name": "Pcb Prototipo Pack De 4",
        "price": "350",
        "quantity": 2,
        "images": [
            "Imagenes/40/40_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 41,
        "name": "Kit Surtido De Transistores, Regulador De Voltaje (16 Pcs)",
        "price": "500",
        "quantity": 1,
        "images": [
            "Imagenes/41/41_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 42,
        "name": "Sensor De Temperatura Y Humedad Arduino",
        "price": "270",
        "quantity": 5,
        "images": [
            "Imagenes/42/42_1.png",
            "Imagenes/42/42_2.png",
            "Imagenes/42/42_3.jpg",
            "Imagenes/42/42_4.jpg",
            "Imagenes/42/42_5.jpg",
            "Imagenes/42/42_6.jpg",
            "Imagenes/42/42_7.jpg"
        ],
        "description": "Descripción:\n\nEl módulo sensor HTU21D es un sensor de temperatura y humedad de alta precisión con comunicación I2C, diseñado para aplicaciones donde se requieren mediciones exactas de las condiciones ambientales. Este sensor es ideal para proyectos con Arduino, proporcionando datos fiables y rápidos sobre temperatura y humedad.\n\nCaracterísticas Técnicas:\n\nSensor: HTU21D.\nComunicación: I2C.\nRango de Medición de Temperatura: -40°C a 125°C.\nPrecisión de Temperatura: ±0.3°C.\nRango de Medición de Humedad: 0% a 100% RH.\nPrecisión de Humedad: ±2% RH.\nVoltaje de Operación: 1.5V a 3.6V.\nConsumo de Corriente: Máximo 500 µA durante la medición, 0.1 µA en modo de espera.\nTiempo de Respuesta: Temperatura - 5 segundos, Humedad - 8 segundos.\nDimensiones: Compacto y fácil de integrar en aplicaciones electrónicas.\nAplicaciones Comunes:\n\nMonitoreo ambiental en interiores.\nSistemas HVAC.\nDispositivos IoT y domótica.\nEstaciones meteorológicas.\nIncluye:\n\n1 x Módulo Sensor de Temperatura y Humedad HTU21D.\nManual de especificaciones y guía de uso.\nBeneficios:\n\nAlta Precisión: Proporciona mediciones exactas de temperatura y humedad.\nFácil Integración: Comunicación I2C para una sencilla implementación en proyectos con microcontroladores.\nVersatilidad: Ideal para una amplia gama de aplicaciones en diversas condiciones ambientales.",
        "code": "#include <Wire.h>\n#include \"Adafruit_HTU21DF.h\"\n\n// Crear una instancia del sensor HTU21D\nAdafruit_HTU21DF htu = Adafruit_HTU21DF();\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"HTU21D test\");\n  \n  // Inicializar el sensor HTU21D\n  if (!htu.begin()) {\n    Serial.println(\"No se encontró el sensor HTU21D. Verifique la conexión.\");\n    while (1);\n  }\n}\n\nvoid loop() {\n  float temp = htu.readTemperature(); // Leer temperatura\n  float humidity = htu.readHumidity(); // Leer humedad\n  \n  Serial.print(\"Temperatura: \");\n  Serial.print(temp);\n  Serial.println(\" *C\");\n  \n  Serial.print(\"Humedad: \");\n  Serial.print(humidity);\n  Serial.println(\" %\");\n\n  delay(2000); // Esperar 2 segundos antes de la siguiente lectura\n}",
        "datasheet": false
    },
    {
        "id": 43,
        "name": "Dip-switch 4 Posiciones (pack De 5)",
        "price": "350",
        "quantity": 1,
        "images": [
            "Imagenes/43/43_1.png",
            "Imagenes/43/43_2.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 44,
        "name": "Chip Cob YXO 50w FRIO",
        "price": "360",
        "quantity": 19,
        "images": [
            "Imagenes/44/44_1.png"
        ],
        "description": "Descripción General:\nBridgelux es una marca reconocida en la industria de la iluminación LED, conocida por sus productos de alta calidad y eficiencia. Los LEDs Bridgelux son utilizados en una amplia gama de aplicaciones, desde iluminación general hasta aplicaciones industriales y comerciales.\n\nChip Original de fábrica. De los mejores en el mercado, con bornera para no soldar.\n\nEspecificación:\n\n1. Fuente de luz: DOB\n2 Color:Blanco frío 6000K\n3Fosfuro: 660nm (otro proveedor utiliza 620nm, por lo que es barato)\n4 Chip:Bridgelux\n5 potencia: 50w\n6. Voltaje de entrada: 220-265V\n7Tamaño:75x40x1.6mm\n8. Material de la carcasa: Aluminio\n9. Vida útil de la fuente:> 50.000 horas\n10 Ángulo de iluminación: 120\n\n 6 funciones para proteger el chip led de larga vida útil.\n\nA1:MOV para protección contra sobretensiones> 4000V pasado\n\nA2: rectificador de puente de 1000V\n\nR3: control de corriente constante y potencia constante\n\nA4: sensor NTC para protección contra sobrecalentamiento pcb\n\nA5: regulador de voltaje para la protección ic vdd\n\nR6: Controlador IC, control de sobretensión y sobrecorriente\n\nA7: puede usar un atenuador led o un atenuador SCR para atenuarlo.\n\nNecesitan sistema de disipación de calor (disipador por lo menos)",
        "code": "",
        "datasheet": false
    },
    {
        "id": 46,
        "name": "ESP32 placa de desarrollo",
        "price": "650",
        "quantity": 3,
        "images": [
            "Imagenes/46/46_1.png"
        ],
        "description": "",
        "code": "#include <WiFi.h>\n\n// Configuración del Wi-Fi\nconst char* ssid = \"TU_SSID\";\nconst char* password = \"TU_PASSWORD\";\n\n// Crear una instancia del servidor en el puerto 80\nWiFiServer server(80);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Conectar al Wi-Fi\n  Serial.print(\"Conectando a \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi conectado.\");\n  Serial.println(\"Dirección IP: \");\n  Serial.println(WiFi.localIP());\n\n  // Iniciar el servidor\n  server.begin();\n}\n\nvoid loop() {\n  // Comprobar si hay un cliente\n  WiFiClient client = server.available();\n  if (client) {\n    Serial.println(\"Nuevo Cliente.\");\n    String currentLine = \"\";\n\n    // Mientras el cliente esté conectado\n    while (client.connected()) {\n      if (client.available()) {\n        char c = client.read();\n        Serial.write(c);\n        if (c == '\n') {\n          if (currentLine.length() == 0) {\n            // Enviar respuesta HTTP\n            client.println(\"HTTP/1.1 200 OK\");\n            client.println(\"Content-type:text/html\");\n            client.println();\n\n            // Contenido del servidor web\n            client.println(\"<!DOCTYPE html><html>\");\n            client.println(\"<head><title>ESP32 Web Server</title></head>\");\n            client.println(\"<body><h1>Hola desde ESP32</h1></body>\");\n            client.println(\"</html>\");\n\n            // La respuesta HTTP se ha completado\n            break;\n          } else {\n            currentLine = \"\";\n          }\n        } else if (c != '\\r') {\n          currentLine += c;\n        }\n      }\n    }\n    // Cerrar la conexión\n    client.stop();\n    Serial.println(\"Cliente Desconectado.\");\n  }\n}",
        "datasheet": false
    },
    {
        "id": 47,
        "name": "Diodo Fr607 x10 (1000V 6A)",
        "price": "190",
        "quantity": 13,
        "images": [
            "Imagenes/47/47_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": true
    },
    {
        "id": 48,
        "name": "Diodo Fr207 x20 (1000V 2A)",
        "price": "80",
        "quantity": 3,
        "images": [
            "Imagenes/48/48_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": true
    },
    {
        "id": 49,
        "name": "Potenciómetro Lineal De 3 Pines, 1k",
        "price": "80",
        "quantity": 10,
        "images": [
            "Imagenes/49/49_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 50,
        "name": "Potenciómetro Lineal De 3 Pines, 2k",
        "price": "80",
        "quantity": 9,
        "images": [
            "Imagenes/50/50_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 51,
        "name": "Potenciómetro Lineal De 3 Pines, 100k",
        "price": "80",
        "quantity": 10,
        "images": [
            "Imagenes/51/51_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 52,
        "name": "Wemos D1 Mini Pro V3.0 Wifi",
        "price": "330",
        "quantity": 10,
        "images": [
            "Imagenes/52/52_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 53,
        "name": "Ne555 Circuito Integrado (10 Unidades)",
        "price": "180",
        "quantity": 4,
        "images": [
            "Imagenes/53/53_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 55,
        "name": "Potenciómetro Lineal De 3 Pines, 1m",
        "price": "80",
        "quantity": 10,
        "images": [
            "Imagenes/55/55_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 56,
        "name": "Potenciómetro Lineal De 3 Pines, 50k",
        "price": "80",
        "quantity": 10,
        "images": [
            "Imagenes/56/56_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 57,
        "name": "Potenciómetro Lineal De 3 Pines, 20k",
        "price": "80",
        "quantity": 10,
        "images": [
            "Imagenes/57/57_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 58,
        "name": "Transistor 2n2222 (100 Unidades)",
        "price": "350",
        "quantity": 4,
        "images": [
            "Imagenes/58/58_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 59,
        "name": "Potenciómetro Lineal De 3 Pines, 250k",
        "price": "80",
        "quantity": 9,
        "images": [
            "Imagenes/59/59_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 60,
        "name": "Triac Bta10-600b (x5 Unidades)",
        "price": "500",
        "quantity": 3,
        "images": [
            "Imagenes/60/60_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 61,
        "name": "Triac Bta16-600b X 4 Unidades                      ",
        "price": "320",
        "quantity": 20,
        "images": [
            "Imagenes/61/61_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 65,
        "name": "Portafusibles De Tubo De Vidrio, 5x20mm (pack X5)",
        "price": "250",
        "quantity": 3,
        "images": [
            "Imagenes/65/65_1.png",
            "Imagenes/65/65_2.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 66,
        "name": "Teclado Membrana 4x5 (arduino U Otros Micros)",
        "price": "150",
        "quantity": 2,
        "images": [
            "Imagenes/66/66_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 67,
        "name": "Sensor De Corriente De Precisión (arduino)",
        "price": "280",
        "quantity": 2,
        "images": [
            "Imagenes/67/67_1.png",
            "Imagenes/67/67_2.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 69,
        "name": "Caja De Fusibles De Tubo De Vidrio, Soplado Rápido (100uds) ",
        "price": "750",
        "quantity": 5,
        "images": [
            "Imagenes/69/69_1.png"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 71,
        "name": "Microcontrolador W806 (placa De Desarrollo)",
        "price": "690",
        "quantity": 2,
        "images": [
            "Imagenes/71/71_1.png"
        ],
        "description": "El microcontrolador W806, fabricado por WinnerMicro, es un MCU versátil que se presenta en un paquete QFN-56 (6x6). Es parte de la serie W800 y ofrece una solución robusta para IoT y sistemas embebidos.\n\nEspecificaciones clave:\nFabricante: WinnerMicro\nPaquete: QFN-56 (6x6)\nNúcleo: ARM Cortex-M4\nVelocidad de reloj: Hasta 240 MHz\nMemoria: Memoria flash y SRAM integradas\nInterfaces: Incluye múltiples opciones de E/S, UART, SPI, I2C, entre otras, para una conectividad versátil.\nPara una hoja de datos detallada, puedes consultar el datasheet del W806 de WinnerMicro.\n\nAplicaciones:\nEl microcontrolador W806 es ideal para una variedad de aplicaciones que incluyen:\n\nDispositivos IoT: Con su potente núcleo y amplio conjunto de interfaces, soporta diversas soluciones IoT.\nSistemas embebidos: Adecuado para aplicaciones embebidas que requieren un rendimiento y conectividad fiables.\nEste microcontrolador se destaca por su equilibrio entre rendimiento y eficiencia energética, lo que lo convierte en una opción popular en la industria para desarrollar soluciones tecnológicas avanzadas.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 72,
        "name": "Sensor De Temperatura Y Humedad De Alta Precisión Aht21",
        "price": "270",
        "quantity": 4,
        "images": [
            "Imagenes/72/72_1.png",
            "Imagenes/72/72_2.jpg",
            "Imagenes/72/72_3.jpg",
            "Imagenes/72/72_4.jpg",
            "Imagenes/72/72_5.jpg",
            "Imagenes/72/72_6.jpg"
        ],
        "description": "El AHT21 es un sensor digital de alta precisión diseñado para medir la temperatura y la humedad. Este módulo es ideal para aplicaciones que requieren una medición precisa y confiable en una variedad de condiciones ambientales. Es un excelente reemplazo para el popular sensor SHT20, proporcionando mejoras en precisión y eficiencia.\n\nCaracterísticas:\n\nSensor: AHT21.\nComunicación: I2C.\nRango de Temperatura: -40°C a 85°C.\nRango de Humedad: 0% a 100% RH.\nPrecisión: ±0.3°C en temperatura y ±2% RH en humedad.\nVoltaje de Operación: 2.2V a 5.5V.\nDimensiones: Compacto y fácil de integrar en proyectos electrónicos.\nAplicaciones Comunes:\n\nMonitoreo ambiental en interiores.\nSistemas HVAC.\nDispositivos IoT y domótica.\nEstaciones meteorológicas.\nIncluye:\n\n1 x Módulo Sensor de Temperatura y Humedad AHT21.\nManual de especificaciones y guía de uso.\nBeneficios:\n\nAlta Precisión: Medición exacta de temperatura y humedad.\nFácil Integración: Comunicación I2C para una fácil implementación en proyectos con microcontroladores.\nVersatilidad: Ideal para una amplia gama de aplicaciones en diversas condiciones ambientales.",
        "code": "#include <Wire.h>\n#include \"AHTxx.h\"\n\nAHTxx aht(AHTXX_ADDRESS_X38, AHT2x_SENSOR); // Inicializar el sensor AHT21\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n  aht.begin();\n}\n\nvoid loop() {\n  float temperature = aht.getTemperature(); // Obtener la temperatura\n  float humidity = aht.getHumidity(); // Obtener la humedad\n\n  Serial.print(\"Temperatura: \");\n  Serial.print(temperature);\n  Serial.println(\" °C\");\n\n  Serial.print(\"Humedad: \");\n  Serial.print(humidity);\n  Serial.println(\" %\");\n\n  delay(2000); // Esperar 2 segundos antes de la siguiente lectura\n}",
        "datasheet": false
    },
    {
        "id": 73,
        "name": "Conversor Dc-dc De Intensidad Y Voltaje Regulables",
        "price": "260",
        "quantity": 15,
        "images": [
            "Imagenes/73/73_1.jpg",
            "Imagenes/73/73_2.jpg",
            "Imagenes/73/73_3.jpg"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 74,
        "name": "Módulo Rele temporizado",
        "price": "390",
        "quantity": 4,
        "images": [
            "Imagenes/74/74_1.jpg",
            "Imagenes/74/74_2.jpg"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 76,
        "name": "Optoacoplador PC817C (20 unidades)",
        "price": "200",
        "quantity": 9,
        "images": [
            "Imagenes/76/76_1.jpg"
        ],
        "description": "Resumen Técnico del Optoacoplador PC817\nEl PC817 es un optoacoplador de propósito general ampliamente utilizado para proporcionar aislamiento eléctrico entre circuitos de entrada y salida. Este dispositivo emplea un diodo emisor de luz infrarroja (LED) y un fototransistor para transferir señales eléctricas a través de un medio óptico, ofreciendo una excelente protección contra interferencias electromagnéticas.\n\nCaracterísticas Principales\nTipo de Dispositivo: Optoacoplador con salida de fototransistor\nAislamiento: 5000 Vrms entre entrada y salida\nEncapsulado: DIP-4\nNúmero de Canales: 1\nEspecificaciones Eléctricas\nVoltaje Máximo de Entrada (V<sub>F</sub>): 1.2V (típico)\nCorriente de Entrada (I<sub>F</sub>): 20 mA (máximo)\nVoltaje de Salida (V<sub>CEO</sub>): 35V (máximo)\nCorriente de Colector (I<sub>C</sub>): 50 mA (máximo)\nRelación de Transferencia de Corriente (CTR): 50% a 600%\nTemperatura de Operación: -30°C a +100°C\nAplicaciones Comunes\nAislamiento de Señales: En sistemas donde es necesario aislar una señal de control de una señal de potencia.\nInterruptores Electrónicos: Para encender y apagar dispositivos sin conexión directa eléctrica.\nProtección de Circuitos: Evitar el daño de componentes sensibles debido a picos de tensión o ruido eléctrico.\nInterfaz de Microcontroladores: Para aislar microcontroladores y otros circuitos lógicos de altas tensiones.\nVentajas\nAlta Capacidad de Aislamiento: Proporciona un aislamiento eléctrico seguro entre la entrada y la salida.\nBajo Consumo de Corriente: Adecuado para aplicaciones de baja potencia.\nAlta Fiabilidad y Durabilidad: Sin partes mecánicas móviles.\nCompatibilidad con Microcontroladores y Otros Circuitos Lógicos: Puede ser fácilmente integrado en sistemas de control y automatización.\nEsquema de Conexión\nEl PC817 tiene cuatro pines:\n\nAnodo del LED (Pin 1)\nCatodo del LED (Pin 2)\nEmisor del Fototransistor (Pin 3)\nColector del Fototransistor (Pin 4)",
        "code": "",
        "datasheet": true
    },
    {
        "id": 77,
        "name": "Led smd RGB (x20)",
        "price": "150",
        "quantity": 10,
        "images": [
            "Imagenes/77/77_1.jpg"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 78,
        "name": "H11AA1 (x4 unidades)",
        "price": "230",
        "quantity": 6,
        "images": [
            "Imagenes/78/78_1.jpg"
        ],
        "description": "El H11AA1 es un optoacoplador (o aislamiento óptico) que se utiliza para transferir señales eléctricas mediante luz, proporcionando aislamiento eléctrico entre su entrada y salida. Este dispositivo es ideal para aplicaciones en las que se requiere aislamiento galvánico para proteger los componentes electrónicos sensibles de ruidos eléctricos y picos de tensión.\n\nCaracterísticas Principales\nTipo de Dispositivo: Optoacoplador\nConfiguración de Salida: Fototransistor de silicio\nAislamiento: 5300 Vrms entre entrada y salida\nEncapsulado: DIP-6\nNúmero de Canales: 1\nEspecificaciones Eléctricas\nVoltaje Máximo de Entrada (V<sub>F</sub>): 1.2V (típico)\nCorriente de Entrada (I<sub>F</sub>): 10 mA (típico), 60 mA (máximo)\nVoltaje de Salida (V<sub>CE</sub>): 30V (máximo)\nCorriente de Colector (I<sub>C</sub>): 50 mA (máximo)\nRelación de Transferencia de Corriente (CTR): 20% a 200%\nTiempo de Respuesta:\nTiempo de Encendido (t<sub>on</sub>): 3 µs\nTiempo de Apagado (t<sub>off</sub>): 2.3 µs\nAplicaciones Comunes\nAislamiento de Señales: En sistemas donde es necesario aislar una señal de control de una señal de potencia.\nInterruptores Electrónicos: Para encender y apagar dispositivos sin conexión directa eléctrica.\nProtección de Circuitos: Evitar el daño de componentes sensibles debido a picos de tensión o ruido eléctrico.\nConversión de Señales: Transferencia de señales entre diferentes niveles de tensión.\nVentajas\nAlta Capacidad de Aislamiento: Proporciona un aislamiento eléctrico seguro entre la entrada y la salida.\nBajo Consumo de Corriente: Adecuado para aplicaciones de baja potencia.\nAlta Fiabilidad y Durabilidad: Sin partes mecánicas móviles.\nCompatibilidad con Microcontroladores y Otros Circuitos Lógicos: Puede ser fácilmente integrado en sistemas de control y automatización.\nEsquema de Conexión\nEl H11AA1 tiene seis pines:\n\nAnodo del LED (Pin 1)\nCatodo del LED (Pin 2)\nNo Conectado (Pin 3)\nEmisor del Transistor (Pin 4)\nColector del Transistor (Pin 5)\nBase del Transistor (Pin 6)",
        "code": "",
        "datasheet": true
    },
    {
        "id": 79,
        "name": "MOC3043 (x2)",
        "price": "150",
        "quantity": 14,
        "images": [
            "Imagenes/79/79_1.jpg"
        ],
        "description": "El MOC3043 es un optoacoplador con salida TRIAC diseñado para la conmutación de corriente alterna (AC). Este dispositivo es ideal para aplicaciones que requieren aislamiento galvánico entre los circuitos de control de baja potencia y las cargas de corriente alterna de alta potencia.\n\nCaracterísticas Principales\nTipo de Dispositivo: Optoacoplador con salida TRIAC\nAislamiento: 7500 Vpeak entre entrada y salida\nEncapsulado: DIP-6\nSalida: TRIAC\nNúmero de Canales: 1\nEspecificaciones Eléctricas\nVoltaje Máximo de Entrada (V<sub>F</sub>): 1.2V (típico)\nCorriente de Entrada (I<sub>F</sub>): 10 mA (típico), 15 mA (máximo)\nVoltaje de Salida (V<sub>DRM</sub>): 400V\nCorriente de Pico No Repetitivo (I<sub>TP</sub>): 1A\nVoltaje de Encendido (V<sub>T</sub>): 1.3V (típico)\nCorriente de Encendido (I<sub>T</sub>): 100 mA (típico)\nCorriente de Retención (I<sub>H</sub>): 280 µA (máximo)\nAislamiento: 7500 Vpeak\nAplicaciones Comunes\nControl de Potencia AC: Para encender y apagar cargas de corriente alterna, como motores, luces y calefactores.\nControl de Motores: Para controlar motores de corriente alterna en aplicaciones industriales y de consumo.\nAislamiento de Señales: Proporciona aislamiento galvánico entre circuitos de control y cargas de alta tensión.\nAutomatización del Hogar: En aplicaciones de domótica para controlar luces y otros electrodomésticos.\nVentajas\nAlta Capacidad de Aislamiento: Proporciona un aislamiento eléctrico seguro entre la entrada y la salida.\nConmutación Sincrónica con el Paso por Cero: Reduce el ruido y las interferencias en la conmutación de corriente alterna.\nBajo Consumo de Corriente de Entrada: Adecuado para aplicaciones de bajo consumo.\nAlta Fiabilidad y Durabilidad: Sin partes mecánicas móviles.\nCompatibilidad con Microcontroladores y Otros Circuitos Lógicos: Puede ser fácilmente integrado en sistemas de control y automatización.\nEsquema de Conexión\nEl MOC3043 tiene seis pines:\n\nAnodo del LED (Pin 1)\nCatodo del LED (Pin 2)\nNo Conectado (Pin 3)\nTerminal A2 del TRIAC (Pin 4)\nTerminal A1 del TRIAC (Pin 5)\nNo Conectado (Pin 6)",
        "code": "int ledPin = 13;    // Pin LED interno del Arduino\nint inputPin = 2;   // Pin conectado al Anodo del LED del MOC3043\nint val = 0;        // Variable para almacenar el valor de entrada\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);   // Establecer el pin LED como salida\n  pinMode(inputPin, OUTPUT); // Establecer el pin de entrada como salida\n  Serial.begin(9600);        // Iniciar la comunicación serial\n}\n\nvoid loop() {\n  digitalWrite(inputPin, HIGH);  // Encender el LED del MOC3043\n  digitalWrite(ledPin, HIGH);    // Encender el LED del Arduino\n  Serial.println(\"Cargando señal AC\");\n  delay(1000);                   // Mantener la señal por 1 segundo\n\n  digitalWrite(inputPin, LOW);   // Apagar el LED del MOC3043\n  digitalWrite(ledPin, LOW);     // Apagar el LED del Arduino\n  Serial.println(\"Señal AC apagada\");\n  delay(1000);                   // Mantener apagado por 1 segundo\n}",
        "datasheet": true
    },
    {
        "id": 80,
        "name": "Voltimetro digital 0-100V 10A",
        "price": "250",
        "quantity": 15,
        "images": [
            "Imagenes/80/80_1.jpg",
            "Imagenes/80/80_2.jpg",
            "Imagenes/80/80_3.jpg"
        ],
        "description": "Descripción General\nEste dispositivo es un medidor digital que puede medir tanto voltaje como corriente continua (DC). Está diseñado para monitorear y mostrar simultáneamente el voltaje y la corriente en sistemas eléctricos y electrónicos. Es ideal para aplicaciones en fuentes de alimentación, paneles solares, sistemas de baterías y proyectos de bricolaje.\n\nEspecificaciones Técnicas\nRango de Medición de Voltaje: 0-100V DC\nRango de Medición de Corriente: 0-10A DC\nPrecisión de Voltaje: ±1% (±1 dígito)\nPrecisión de Corriente: ±1% (±1 dígito)\nResolución de Voltaje: 0.1V\nResolución de Corriente: 0.01A\nFuente de Alimentación: 4-30V DC (alimentación externa)\nConsumo de Energía: < 20mA\nPantalla: LED de 3 dígitos, doble color (rojo para voltaje y azul para corriente)\nDimensiones: 48mm x 29mm x 21mm (Largo x Ancho x Alto)\nConexiones:\nRojo: Alimentación positiva (Vcc)\nNegro: Alimentación negativa (GND)\nAmarillo: Medición de voltaje (V)\nNegro (más grueso): Medición de corriente (A)\nCaracterísticas\nPantalla Dual: Muestra simultáneamente el voltaje y la corriente con diferentes colores para una fácil lectura.\nAlta Precisión: Medición precisa de voltaje y corriente con una resolución adecuada para aplicaciones de precisión.\nFácil Instalación: Diseño compacto con cables de conexión estándar y conectores para una fácil instalación en paneles y dispositivos.\nProtección: Protección contra inversión de polaridad para evitar daños al dispositivo.\nAplicaciones\nFuentes de Alimentación: Monitoreo de voltaje y corriente en fuentes de alimentación de laboratorio y proyectos de bricolaje.\nSistemas de Energía Solar: Supervisión del voltaje y la corriente en sistemas de energía solar para asegurar el rendimiento y la eficiencia.\nBaterías y Cargadores: Verificación del estado de carga y descarga en sistemas de baterías y cargadores.\nProyectos Electrónicos: Ideal para proyectos de electrónica que requieren monitoreo de energía, como robots, controladores y dispositivos de prueba.\nAutomoción: Medición de parámetros eléctricos en vehículos y sistemas automotrices.\n\nInstrucciones de Conexión\nAlimentación del Medidor:\n\nConecte el cable rojo al positivo de la fuente de alimentación (Vcc).\nConecte el cable negro delgado al negativo de la fuente de alimentación (GND).\nMedición de Voltaje:\n\nConecte el cable amarillo al punto donde desea medir el voltaje.\nMedición de Corriente:\n\nConecte el cable negro grueso en serie con la carga donde desea medir la corriente.\n\nNotas\nSeguridad: Asegúrese de conectar correctamente los cables para evitar daños al dispositivo y a los componentes del circuito.\n\nCalibración: El dispositivo viene calibrado de fábrica, pero se recomienda verificar las mediciones con un multímetro de precisión para aplicaciones críticas.\nTemperatura de Operación: Utilizar dentro del rango de temperatura especificado para garantizar la precisión y la vida útil del dispositivo.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 81,
        "name": "Tarjeta expansion micro SD",
        "price": "150",
        "quantity": 10,
        "images": [
            "Imagenes/81/81_1.jpg",
            "Imagenes/81/81_2.jpg",
            "Imagenes/81/81_3.jpg"
        ],
        "description": "Descripción General\nEl módulo de expansión de almacenamiento Micro SD es un componente electrónico diseñado para facilitar la integración de tarjetas micro SD en proyectos de microcontroladores y sistemas embebidos. Este módulo permite la lectura y escritura de datos en una tarjeta micro SD, proporcionando una solución de almacenamiento portátil y de alta capacidad.\n\nEspecificaciones Técnicas\nCompatibilidad de Tarjetas: Micro SD, Micro SDHC\nInterfaz de Comunicación: SPI (Serial Peripheral Interface)\nVoltaje de Operación: 3.3V / 5V (tolerancia a nivel de señal de 5V)\nCorriente de Operación: 80mA (típico)\nVelocidad de Transferencia de Datos: Hasta 25 Mbps en modo SPI\nTemperatura de Operación: -25°C a 85°C\nDimensiones: 42mm x 24mm\nCaracterísticas\nCompatibilidad Universal: Compatible con una amplia gama de tarjetas micro SD, incluyendo SD y SDHC.\nInterfaz SPI: Utiliza la interfaz SPI estándar para la comunicación con microcontroladores como Arduino, ESP8266, ESP32, STM32, y otros.\nTolerancia de Voltaje: Soporta niveles de señal de 3.3V y 5V, lo que lo hace compatible con la mayoría de los microcontroladores.\nFactor de Forma Compacto: Diseño compacto que facilita la integración en proyectos con espacio limitado.\nPinout\nGND: Tierra\n3.3V: Alimentación de 3.3V\n5V: Alimentación de 5V\nCS: Chip Select (Pin de selección del dispositivo SPI)\nMOSI: Master Out Slave In (Pin de datos del SPI)\nMISO: Master In Slave Out (Pin de datos del SPI)\nSCK: Serial Clock (Pin de reloj del SPI)\nAplicaciones\nProyectos de Datos: Ideal para proyectos que requieren almacenamiento de datos, como dataloggers y sistemas de registro de eventos.\nSistemas de Archivos: Permite la creación de sistemas de archivos en proyectos de microcontroladores, facilitando el almacenamiento y acceso a archivos de gran tamaño.\nMultimedia: Adecuado para proyectos de audio y video que necesitan almacenar y reproducir archivos multimedia.\nDesarrollo y Prototipado: Útil en el desarrollo y prototipado de sistemas embebidos que requieren almacenamiento externo.\nEjemplo de Conexión con Arduino\nConexiones Físicas:\n\nGND: Conectar al pin GND del Arduino.\n3.3V: Conectar al pin 3.3V del Arduino.\nCS: Conectar al pin 10 del Arduino.\nMOSI: Conectar al pin 11 del Arduino.\nMISO: Conectar al pin 12 del Arduino.\nSCK: Conectar al pin 13 del Arduino.",
        "code": "#include <SPI.h>\n#include <SD.h>\n\nconst int chipSelect = 10;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(chipSelect, OUTPUT);\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"No se pudo inicializar la tarjeta SD.\");\n    return;\n  }\n  Serial.println(\"Tarjeta SD inicializada.\");\n  File dataFile = SD.open(\"datalog.txt\", FILE_WRITE);\n  if (dataFile) {\n    dataFile.println(\"Datos de ejemplo.\");\n    dataFile.close();\n    Serial.println(\"Datos guardados.\");\n  } else {\n    Serial.println(\"Error al abrir el archivo.\");\n  }\n}\n\nvoid loop() {\n  // Código adicional\n}",
        "datasheet": false
    },
    {
        "id": 84,
        "name": "Grabadora Eeprom kit",
        "price": "990",
        "quantity": 1,
        "images": [],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 85,
        "name": "Lampara 200W",
        "price": "5200",
        "quantity": 2,
        "images": [],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 87,
        "name": "Interruptor palanca (x10)",
        "price": "350",
        "quantity": 9,
        "images": [
            "Imagenes/87/87_1.jpg",
            "Imagenes/87/87_2.jpg",
            "Imagenes/87/87_3.jpg"
        ],
        "description": "Modelo: MTS-103\nTipo de Interruptor: Palanca de 3 pines, 3 posiciones\nMaterial: Plástico y metal\nAplicaciones Comunes: Uso en automóviles, proyectos electrónicos y sistemas eléctricos.\n\nEspecificaciones Técnicas\nConfiguración de Pinos: 3 pines\nPosiciones de Conmutación: 3 (ON-ON-ON)\nVoltaje Nominal: 6A/125V AC\nCorriente Nominal: 6A\nMaterial de la Carcasa: Plástico de alta resistencia\nMaterial de los Contactos: Metal\nCaracterísticas\nDurabilidad: Diseñado para soportar múltiples ciclos de encendido y apagado.\nResistencia al Desgaste: Alta resistencia mecánica y eléctrica.\nFacilidad de Uso: Operación simple mediante una palanca de conmutación.\nMontaje: Se monta fácilmente en paneles, ideal para personalización y proyectos DIY.\nAplicaciones\nAutomóviles: Control de luces, accesorios y otros dispositivos eléctricos.\nProyectos Electrónicos: Interruptor general para circuitos, control de dispositivos.\nSistemas Eléctricos: Uso en tableros de control y sistemas de conmutación.\nBeneficios\nConfiabilidad: Alta confiabilidad en ambientes exigentes.\nVersatilidad: Compatible con una amplia variedad de aplicaciones.\nCosto Efectivo: Solución económica para necesidades de conmutación eléctrica.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 88,
        "name": "Módulo De Refuerzo De Dc-dc Xl6009",
        "price": "300",
        "quantity": 2,
        "images": [
            "Imagenes/88/88_1.png",
            "Imagenes/88/88_2.jpg",
            "Imagenes/88/88_3.jpg",
            "Imagenes/88/88_4.png",
            "Imagenes/88/88_5.jpg",
            "Imagenes/88/88_6.jpg"
        ],
        "description": "El XL6009 es un convertidor DC-DC Step-Up (boost converter) de alta eficiencia, ideal para aplicaciones de potencia donde se requiere elevar el voltaje de entrada a un nivel de salida superior. A continuación, se presenta un resumen técnico del XL6009:\n\nCaracterísticas Principales:\nRango de Voltaje de Entrada: 3.0V a 32V.\nRango de Voltaje de Salida: 5V a 35V (ajustable).\nCorriente de Salida: Hasta 2.5A.\nFrecuencia de Conmutación: 400kHz.\nEficiencia: Hasta 94%.\nProtecciones: Protección contra sobrecorriente, protección térmica y protección contra cortocircuitos.\n\nEspecificaciones Técnicas:\nVoltaje de Entrada (Vin): 3.0V - 32V.\nVoltaje de Salida (Vout): 5V - 35V, ajustable mediante potenciómetro.\nCorriente de Salida (Iout): Hasta 2.5A (recomendado mantenerlo por debajo de 2A para una operación continua y segura).\nFrecuencia de Conmutación: 400kHz.\nEficiencia de Conversión: Típicamente 92%, puede llegar hasta 94%.\nTemperatura de Operación: -40°C a +85°C.\nDimensiones del Módulo: 43mm x 21mm x 14mm.\n\nPinout:\nVin: Entrada de voltaje.\nGND: Conexión a tierra.\nVout: Salida de voltaje ajustable.\n\nAplicaciones Comunes:\nAlimentación de circuitos electrónicos a partir de baterías.\nProyectos de energía solar.\nSistemas de alimentación para LEDs de alta potencia.\nEquipos de telecomunicaciones.\nProyectos de robótica y microcontroladores.\nEjemplo de Conexión:\nVin: Conectar al suministro de energía (batería o fuente de alimentación) entre 3V y 32V.\nGND: Conectar al terminal negativo de la fuente de energía y al terminal negativo de la carga.\nVout: Conectar al dispositivo que se desea alimentar, asegurándose de ajustar el potenciómetro para obtener el voltaje de salida deseado (entre 5V y 35V).\n\nAjuste del Voltaje de Salida:\nEl voltaje de salida se puede ajustar utilizando el potenciómetro incorporado en el módulo. Gire el potenciómetro en sentido horario para aumentar el voltaje de salida y en sentido antihorario para disminuirlo.\n\nNotas de Diseño:\nAsegúrese de que el voltaje de entrada sea al menos 3V inferior al voltaje de salida deseado para un rendimiento óptimo.\nSe recomienda añadir un condensador de desacoplamiento cerca de la entrada y la salida del módulo para reducir el ruido y mejorar la estabilidad.\n\nAdvertencias:\nEvite exceder los valores máximos especificados para evitar daños al módulo.\nAl manejar corrientes cercanas al límite máximo (2.5A), asegúrese de proporcionar una buena disipación térmica para evitar el sobrecalentamiento.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 89,
        "name": "Pack de 30 Cables Dupont de 30 cm - 10M-M, 10H-H, 10M-H",
        "price": "170",
        "quantity": 7,
        "images": [
            "Imagenes/89/89_1.jpg",
            "Imagenes/89/89_2.jpg",
            "Imagenes/89/89_3.jpg",
            "Imagenes/89/89_4.jpg",
            "Imagenes/89/89_5.jpg"
        ],
        "description": "Descripción:\n\nEste pack de cables Dupont de 30 cm es ideal para todos tus proyectos electrónicos, especialmente aquellos que involucren Arduino, Raspberry Pi y otros microcontroladores. Cada pack incluye 30 cables en total, con las siguientes configuraciones:\n\n10 cables Macho-Macho\n10 cables Hembra-Hembra\n10 cables Macho-Hembra\nCaracterísticas:\n\nLongitud: 30 cm cada cable.\nConectores: Macho-Macho, Hembra-Hembra, Macho-Hembra.\nMaterial de Alta Calidad: Los cables están fabricados con materiales de alta calidad, garantizando durabilidad y una conexión segura.\nVersatilidad: Perfectos para prototipos, pruebas y proyectos permanentes. Facilitan la conexión entre diferentes componentes y módulos sin necesidad de soldadura.\nCompatibilidad: Compatible con una amplia gama de dispositivos y placas, incluidos Arduino, Raspberry Pi, Breadboards y otros módulos electrónicos.\nAplicaciones Comunes:\n\nConexión de sensores, módulos y otros dispositivos electrónicos.\nProyectos de robótica.\nPrototipado rápido y desarrollo de circuitos electrónicos.\nProyectos de educación y aprendizaje en electrónica.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 90,
        "name": "Módulo Sensor de Luz Ambiental Digital TSL2584TSV con Comunicación I2C",
        "price": "530",
        "quantity": 4,
        "images": [
            "Imagenes/90/90_1.jpg",
            "Imagenes/90/90_2.jpg",
            "Imagenes/90/90_3.jpg"
        ],
        "description": "Características Técnicas del TSL2584TSV\nRango Dinámico: Hasta 1,000,000 lux.\nTiempo de Integración: Programable desde 50 ms hasta 400 ms.\nResolución: Alta resolución de 16 bits.\nLinealidad: ±10% sobre un rango de 3 órdenes de magnitud.\nTemperatura de Operación: -40°C a 85°C.\nConsumo de Corriente: Operación de 240 µA, modo de espera de 2.2 µA.\nTipo de Salida: Datos digitales I2C.\nDimensiones: 2 mm x 2 mm x 0.7 mm (encapsulado LGA).\nVentajas:\n\nAlta Precisión: Proporciona mediciones precisas en una amplia gama de condiciones de iluminación.\nBajo Consumo: Ideal para aplicaciones portátiles y dispositivos de baja potencia.\nCompacto: Fácil de integrar en proyectos con restricciones de espacio.",
        "code": "#include <Wire.h>\n\n#define TSL2584_ADDR 0x39\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n  \n  // Inicializar el sensor\n  Wire.beginTransmission(TSL2584_ADDR);\n  Wire.write(0x80 | 0x00); // Comando para encender el sensor\n  Wire.write(0x03); // Encender el sensor\n  Wire.endTransmission();\n}\n\nvoid loop() {\n  Wire.beginTransmission(TSL2584_ADDR);\n  Wire.write(0x80 | 0x0C); // Comando para leer datos de luz\n  Wire.endTransmission();\n  \n  Wire.requestFrom(TSL2584_ADDR, 2);\n  if (Wire.available() == 2) {\n    uint16_t lux = Wire.read();\n    lux |= (Wire.read() << 8);\n    Serial.print(\"Luz: \");\n    Serial.print(lux);\n    Serial.println(\" lux\");\n  }\n  \n  delay(2000);\n}",
        "datasheet": false
    },
    {
        "id": 91,
        "name": "Módulo Sensor de Temperatura y Humedad AHT20 I2C",
        "price": "250",
        "quantity": 4,
        "images": [
            "Imagenes/91/91_1.jpg",
            "Imagenes/91/91_2.jpg",
            "Imagenes/91/91_3.jpg",
            "Imagenes/91/91_4.jpg",
            "Imagenes/91/91_5.jpg",
            "Imagenes/91/91_6.jpg"
        ],
        "description": "Descripción:\n\nEl módulo de sensor de temperatura y humedad AHT20 es una versión mejorada de los sensores populares como el DHT11 y AHT10. Diseñado para proporcionar mediciones precisas y fiables, este sensor utiliza comunicación I2C, lo que facilita su integración en proyectos con Arduino y otros microcontroladores.\n\nCaracterísticas Técnicas:\n\nSensor: AHT20.\nComunicación: I2C.\nRango de Temperatura: -40°C a 85°C.\nPrecisión de Temperatura: ±0.3°C.\nRango de Humedad: 0% a 100% RH.\nPrecisión de Humedad: ±2% RH.\nVoltaje de Operación: 2.2V a 5.5V.\nConsumo de Corriente: 0.6 mA en modo de medición.\nDimensiones: Compacto y fácil de integrar en aplicaciones electrónicas.\nAplicaciones Comunes:\n\nMonitoreo ambiental en interiores.\nSistemas HVAC.\nDispositivos IoT y domótica.\nEstaciones meteorológicas.",
        "code": "#include <Wire.h>\n#include \"Adafruit_AHTX0.h\"\n\n// Crear una instancia del sensor AHT20\nAdafruit_AHTX0 aht;\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n\n  // Inicializar el sensor AHT20\n  if (!aht.begin()) {\n    Serial.println(\"No se encontró el sensor AHT20. Verifique la conexión.\");\n    while (1) delay(10);\n  }\n  Serial.println(\"Sensor AHT20 inicializado correctamente.\");\n}\n\nvoid loop() {\n  sensors_event_t humidity, temp;\n  aht.getEvent(&humidity, &temp);\n\n  Serial.print(\"Temperatura: \");\n  Serial.print(temp.temperature);\n  Serial.println(\" °C\");\n\n  Serial.print(\"Humedad: \");\n  Serial.print(humidity.relative_humidity);\n  Serial.println(\" %\");\n\n  delay(2000); // Esperar 2 segundos antes de la siguiente lectura\n}",
        "datasheet": false
    },
    {
        "id": 94,
        "name": "Módulo de Pantalla OLED I2C 0.96 pulgadas 128x64 SSD1306 para Arduino",
        "price": "320",
        "quantity": 4,
        "images": [
            "Imagenes/94/94_1.jpg"
        ],
        "description": "Descripción\nEl módulo de pantalla OLED I2C de 0.96 pulgadas con resolución 128x64 y controlador SSD1306 es una excelente opción para agregar una interfaz visual a tus proyectos de Arduino. Este tipo de pantalla utiliza la interfaz I2C, lo que permite una fácil conexión y comunicación con el microcontrolador utilizando solo dos pines (SDA y SCL).\n\nCaracterísticas:\nResolución: 128x64 píxeles.\nInterfaz: I2C.\nControlador: SSD1306.\nTamaño: 0.96 pulgadas.\nColor: Blanco.\nVoltaje de operación: 3.3V - 5V.\nBajo consumo de energía: Ideal para proyectos portátiles.\n\nCódigo de Ejemplo para Arduino\nEste código utiliza la librería Adafruit SSD1306 y Adafruit GFX para manejar la pantalla OLED.\n\nInstalación de Librerías\nAntes de cargar el código en tu Arduino, asegúrate de instalar las librerías necesarias:\n\nAbre el IDE de Arduino.\nVe a Sketch > Include Library > Manage Libraries.\nBusca y instala Adafruit SSD1306 y Adafruit GFX.\nConexiones\nVCC: 3.3V o 5V (según tu configuración de Arduino).\nGND: GND.\nSDA: A4 (para Arduino UNO).\nSCL: A5 (para Arduino UNO).",
        "code": "#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n\n// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)\n#define OLED_RESET    -1 // Reset pin # (or -1 if sharing Arduino reset pin)\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\n\nvoid setup() {\n  // Initialize with the I2C addr 0x3C (for the 128x64)\n  if(!display.begin(SSD1306_I2C_ADDRESS, OLED_RESET)) {\n    Serial.println(F(\"SSD1306 allocation failed\"));\n    for(;;);\n  }\n  \n  // Clear the buffer\n  display.clearDisplay();\n\n  // Display static text\n  display.setTextSize(1);      // Normal 1:1 pixel scale\n  display.setTextColor(SSD1306_WHITE); // Draw white text\n  display.setCursor(0, 0);     // Start at top-left corner\n  display.println(F(\"Hola, Mundo!\"));\n  display.display();\n  \n  delay(2000); // Pause for 2 seconds\n  \n  // Draw a simple rectangle\n  display.clearDisplay();\n  display.drawRect(10, 10, 50, 30, SSD1306_WHITE);\n  display.display();\n}\n\nvoid loop() {\n  // Nothing to do here\n}",
        "datasheet": false
    },
    {
        "id": 95,
        "name": "Mini Módulo regulador de Voltaje DC-DC Buck con Protección",
        "price": "130",
        "quantity": 10,
        "images": [
            "Imagenes/95/95_1.jpg",
            "Imagenes/95/95_2.jpg",
            "Imagenes/95/95_3.jpg",
            "Imagenes/95/95_4.jpg",
            "Imagenes/95/95_5.jpg",
            "Imagenes/95/95_6.jpg"
        ],
        "description": "Descripción\nEste módulo regulador de voltaje DC-DC Buck es ideal para proyectos electrónicos que requieren una fuente de alimentación estable. Cuenta con un inductor de moldeado integral, un chip de estabilización de voltaje inteligente con protección automática de apagado a 85 grados, potenciómetro ajustable para un ajuste preciso del voltaje, y capacitancia de onda de alta frecuencia para una mayor eficiencia. Además, incluye protección de conexión inversa, garantizando la seguridad de tus componentes electrónicos. Perfecto para proyectos de Arduino y aplicaciones DIY.\n\nDetalles Técnicos\nVoltaje de Entrada: 4.5V a 28V\nVoltaje de Salida: 0.8V a 20V ajustable\nCorriente de Salida: Hasta 3A\nFrecuencia de Conmutación: 150 kHz\nEficiencia: Hasta 92%\nProtección: Protección contra sobrecorriente, sobretemperatura y cortocircuito\nDimensiones: 22mm x 17mm x 4mm (L x W x H)\nPeso: 3g\nTemperatura de Operación: -40°C a 85°C",
        "code": "",
        "datasheet": false
    },
    {
        "id": 96,
        "name": "Sensor de Luz TEMT6000 Lux para Arduino",
        "price": "200",
        "quantity": 2,
        "images": [
            "Imagenes/96/96_1.jpg",
            "Imagenes/96/96_2.jpg",
            "Imagenes/96/96_3.jpg",
            "Imagenes/96/96_4.jpg",
            "Imagenes/96/96_5.jpg",
            "Imagenes/96/96_6.jpg"
        ],
        "description": "Descripción\nEl sensor de luz TEMT6000 está diseñado para detectar la luz ambiental y es ideal para proyectos con Arduino. Este sensor mide la intensidad lumínica en lux, proporcionando una salida analógica que es proporcional a la intensidad de la luz que recibe. Perfecto para aplicaciones como control automático de iluminación, sistemas de monitoreo ambiental, y proyectos de electrónica DIY.\n\nDetalles Técnicos\nRango de Detección: 0 a 1000 Lux\nVoltaje de Operación: 3.3V a 5V\nSalida: Señal analógica\nTiempo de Respuesta: Rápido\nCompatibilidad: Compatible con Arduino y otros microcontroladores\nDimensiones: Compacto y fácil de integrar\nAplicaciones\nControl de iluminación automática\nMonitoreo de luz ambiental\nProyectos de domótica y electrónica DIY",
        "code": "",
        "datasheet": false
    },
    {
        "id": 97,
        "name": "L137MRI",
        "price": "180",
        "quantity": 10,
        "images": [
            "Imagenes/97/97_2.png"
        ],
        "description": "Consumo de energía 50mW a 265VAC\nLímite de corriente pulso a pulso\nProtección contra sobrecarga\nProtección contra sobretensión\nProtección contra sobrecorriente anormal\nSenseFet interno de alto voltaje 700V\nArranque suave incorporado 15ms\nRango de temperatura de -20C a 125C\nMedidas 9 x 6 mm",
        "code": "",
        "datasheet": false
    },
    {
        "id": 99,
        "name": "Módulo Bms 3s 60a Balanceado Para Baterías De Litio",
        "price": "480",
        "quantity": 15,
        "images": [
            "Imagenes/99/99_1.jpg",
            "Imagenes/99/99_2.jpg",
            "Imagenes/99/99_3.jpg"
        ],
        "description": "Protege tus baterías de litio con el Módulo BMS 3S 60A, ideal para sistemas de 11.1V y 12.6V. Este módulo ofrece protección contra sobrecarga, sobredescarga, sobrecorriente y cortocircuitos. Equipado con MOSFETs de alta calidad, garantiza un rendimiento seguro y eficiente. Perfecto para aplicaciones de alta demanda como vehículos eléctricos, herramientas eléctricas y más.\n\nCaracterísticas:\n\nConfiguración: 3S (3 celdas en serie)\nCorriente de descarga: 60A\nProtección: Sobrecarga (4.2V por celda), Sobredescarga (2.5-3.0V por celda)\nAplicaciones: Baterías de litio para vehículos eléctricos, herramientas eléctricas, y más.\nDetalles de conexión\nCarga: (+) y (-)\nDescarga: (+) y (-)\nCeldas: 0V, 4.2V, 8.4V, 12.6V",
        "code": "",
        "datasheet": false
    },
    {
        "id": 100,
        "name": "Módulo Expansor de I/O I2C PCA9548A 8 Canales HW-617\n\n",
        "price": "220",
        "quantity": 20,
        "images": [
            "Imagenes/100/100_1.jpg",
            "Imagenes/100/100_2.jpg",
            "Imagenes/100/100_3.jpg",
            "Imagenes/100/100_4.jpg",
            "Imagenes/100/100_5.jpg",
            "Imagenes/100/100_6.jpg"
        ],
        "description": "Descripción eléctrica detallada:\nEste módulo expansor de I/O I2C basado en el PCA9548A es ideal para ampliar la cantidad de dispositivos I2C conectados a un microcontrolador. El PCA9548A permite la multiplexación de hasta 8 buses I2C independientes, proporcionando mayor flexibilidad en aplicaciones que requieren conectar múltiples sensores o dispositivos I2C sin conflictos de dirección.\n\nCaracterísticas principales:\n\nVoltaje de funcionamiento: 2.3V a 5.5V\nRango de temperatura de operación: -40°C a 85°C\nInterfaz: I2C\nMultiplexación: 8 canales I2C\nDirecciones I2C configurables: A través de los pines A0, A1 y A2\nConsumo de corriente: < 1mA en operación normal\nDimensiones: 27mm x 16mm\nCompatibilidad: Compatible con sistemas de 3.3V y 5V, ideal para proyectos con Arduino, Raspberry Pi, y otros microcontroladores.\nAplicaciones:\n\nAmpliación de puertos I2C en proyectos de automatización y control.\nIntegración de múltiples sensores en sistemas de adquisición de datos.\nDesarrollo de sistemas embebidos y prototipos con alta demanda de dispositivos I2C.",
        "code": "#include <Wire.h>\n\n// Dirección I2C del PCA9548A\n#define PCA9548A_ADDRESS 0x70\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin(); // Iniciar el bus I2C\n\n  // Seleccionar el canal 0 del PCA9548A\n  selectChannel(0);\n  \n  // Ejemplo de comunicación I2C con un dispositivo en el canal 0\n  Wire.beginTransmission(0x40); // Dirección del dispositivo en el canal 0\n  Wire.write(0x00); // Comando o registro a escribir\n  Wire.endTransmission();\n}\n\nvoid loop() {\n  // Ejemplo: Leer datos de un sensor en el canal 0\n  selectChannel(0);\n  Wire.requestFrom(0x40, 2); // Solicitar 2 bytes del dispositivo en el canal 0\n\n  if (Wire.available() == 2) {\n    int data = Wire.read() << 8 | Wire.read();\n    Serial.println(data);\n  }\n\n  delay(1000); // Esperar 1 segundo antes de leer nuevamente\n}\n\n// Función para seleccionar el canal del PCA9548A\nvoid selectChannel(uint8_t channel) {\n  if (channel > 7) return; // Verificar que el canal esté en el rango 0-7\n  Wire.beginTransmission(PCA9548A_ADDRESS);\n  Wire.write(1 << channel); // Enviar la máscara del canal\n  Wire.endTransmission();\n}",
        "datasheet": false
    },
    {
        "id": 101,
        "name": "Sensor de Efecto Hall 41F (x5)",
        "price": "170",
        "quantity": 12,
        "images": [
            "Imagenes/101/101_1.jpg",
            "Imagenes/101/101_2.jpg",
            "Imagenes/101/101_3.jpg",
            "Imagenes/101/101_4.jpg",
            "Imagenes/101/101_5.jpg"
        ],
        "description": "Descripción Detallada Eléctrica\nCaracterísticas Generales:\n\nModelo: 41F\nTipo: Sensor de Efecto Hall\nEncapsulado: TO-92\nConfiguración de Pines:\nPin 1: Vcc (Alimentación)\nPin 2: GND (Tierra)\nPin 3: Salida\nEspecificaciones Eléctricas:\n\nTensión de Alimentación (Vcc): 4.5V a 24V\nCorriente de Alimentación: Máx. 10 mA\nVoltaje de Salida: Niveles TTL\nTemperatura de Funcionamiento: -40°C a 125°C\nSensibilidad: 5 mT (miliTesla)\nFuncionamiento:\nEl sensor de efecto Hall 41F detecta la presencia de un campo magnético perpendicular al sensor. Cuando un campo magnético con una intensidad mínima de 5 mT se acerca al sensor, éste genera una señal de salida digital. La salida es un pulso cuadrado que cambia de estado (de bajo a alto) en presencia del campo magnético y regresa a su estado original cuando el campo desaparece.\n\nAplicaciones:\n\nDetectores de posición\nContadores de velocidad\nSensores de proximidad\nMedidores de flujo\nVentajas:\n\nAlta sensibilidad al campo magnético\nBajo consumo de energía\nSalida digital fácil de integrar con microcontroladores\nAmplio rango de voltaje de operación\nConexiones Típicas:\n\nConectar el pin 1 (Vcc) a la fuente de alimentación (4.5V a 24V).\nConectar el pin 2 (GND) a tierra.\nConectar el pin 3 (Salida) a un pin de entrada digital de un microcontrolador o a un circuito de lectura.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 102,
        "name": "Pantalla LED 0.36 pulgadas 3 hilos - Rojo",
        "price": "130",
        "quantity": 25,
        "images": [
            "Imagenes/102/102_1.jpg",
            "Imagenes/102/102_2.jpg",
            "Imagenes/102/102_3.jpg",
            "Imagenes/102/102_4.jpg"
        ],
        "description": "Descripción detallada eléctrica\nDescripción del producto:\nPresentamos la Pantalla LED de 0.36 pulgadas con conexión de 3 hilos y color rojo, ideal para proyectos electrónicos y aplicaciones de medición. Este módulo de visualización es perfecto para mostrar valores numéricos de voltaje, corriente, temperatura, entre otros, de manera clara y precisa.\n\nCaracterísticas técnicas:\n\nTamaño de la pantalla: 0.36 pulgadas.\nColor del LED: Rojo.\nNúmero de dígitos: 3 dígitos.\nConexión: 3 hilos (positivo, negativo, señal).\nVoltaje de funcionamiento: 3.5V a 30V DC.\nConsumo de corriente: Menos de 20mA.\nPrecisión: ±1% (según el rango de medición y condiciones de operación).\nRango de medición de voltaje: 0 a 99.9V DC.\nRango de medición de corriente: Variable según configuración y resistencias shunt (no incluidas).\nEspecificaciones eléctricas:\n\nConexión de los hilos:\n\nRojo: Conexión al positivo de la fuente de alimentación.\nNegro: Conexión al negativo de la fuente de alimentación (tierra).\nBlanco (señal): Conexión a la señal de entrada a medir (voltaje o corriente).\nConfiguración de voltaje:\n\nPara medir voltaje, conecte el hilo blanco directamente al punto de medición.\nAsegúrese de que el voltaje de medición esté dentro del rango especificado (0-99.9V DC).\nConfiguración de corriente:\n\nPara medir corriente, es necesario usar una resistencia shunt adecuada (no incluida).\nLa señal de corriente se convierte en un voltaje proporcional a través de la resistencia shunt, el cual se mide por el módulo.\nConfigure el sistema para que el voltaje a través de la resistencia shunt no exceda el rango de medición del módulo.\nAplicaciones:\n\nMedición de voltaje en baterías, fuentes de alimentación, y sistemas de energía.\nMonitoreo de corriente en proyectos electrónicos.\nDisplay de valores en sistemas de control y automatización.\nVentajas:\n\nAlta visibilidad gracias a sus dígitos LED rojos.\nFácil instalación y conexión con solo 3 hilos.\nBajo consumo de energía y amplio rango de voltaje de operación.",
        "code": "// Define the pin for the signal input\nconst int signalPin = A0;\n\n// Variables for storing voltage value\nfloat voltage = 0.0;\nint rawValue = 0;\n\nvoid setup() {\n  // Initialize the serial communication\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // Read the raw value from the analog pin\n  rawValue = analogRead(signalPin);\n  \n  // Convert the raw value to voltage (assuming a 5V reference voltage)\n  voltage = rawValue * (5.0 / 1023.0);\n  \n  // Print the voltage to the serial monitor\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);\n  Serial.println(\" V\");\n  \n  // Wait for a while before taking the next reading\n  delay(1000);\n}",
        "datasheet": false
    },
    {
        "id": 103,
        "name": "Pack de 5 Reguladores de Voltaje Ajustables LM317 - Alta Precisión y Fiabilidad",
        "price": "160",
        "quantity": 25,
        "images": [
            "Imagenes/103/103_1.jpg",
            "Imagenes/103/103_2.jpg",
            "Imagenes/103/103_3.jpg",
            "Imagenes/103/103_4.jpg",
            "Imagenes/103/103_5.jpg",
            "Imagenes/103/103_6.jpg"
        ],
        "description": "Este paquete incluye 5 reguladores de voltaje ajustables LM317, ideales para tus proyectos electrónicos que requieren un control preciso del voltaje. El LM317 es un regulador de voltaje lineal que puede proporcionar una corriente de salida de hasta 1.5 A con un rango de voltaje de salida ajustable de 1.25 V a 37 V.\n\nCaracterísticas Técnicas:\nCorriente de Salida: Hasta 1.5 A\nRango de Voltaje de Salida: 1.25 V a 37 V\nProtección Contra Cortocircuitos: Incorporada para proteger tus circuitos\nRegulación de Voltaje de Precisión: Ajustable mediante un divisor de resistencia externo\nTemperatura de Operación: -55°C a +150°C\nCompensación de Térmica: Garantiza estabilidad y precisión en un amplio rango de temperaturas\nAplicaciones:\nFuentes de alimentación ajustables\nRegulación de voltaje para circuitos integrados\nSistemas de carga de baterías\nElectrónica de consumo y equipos industriales\nVentajas del Producto:\nAlta Fiabilidad: Fabricado con estándares de calidad para asegurar un rendimiento óptimo\nVersatilidad: Adecuado para una amplia gama de aplicaciones electrónicas\nProtección y Seguridad: Incluye protección contra sobrecargas y cortocircuitos",
        "code": "",
        "datasheet": false
    },
    {
        "id": 104,
        "name": "Pack de 5 Reguladores de Voltaje L7805CV - 5V Estables y Fiables",
        "price": "150",
        "quantity": 30,
        "images": [
            "Imagenes/104/104_1.jpg",
            "Imagenes/104/104_2.jpg",
            "Imagenes/104/104_3.jpg",
            "Imagenes/104/104_4.jpg",
            "Imagenes/104/104_5.jpg"
        ],
        "description": "Este paquete incluye 5 reguladores de voltaje lineales L7805CV, perfectos para tus proyectos electrónicos que requieren un suministro de voltaje estable. El L7805CV es un regulador de voltaje fijo que proporciona una salida de 5V con una corriente de salida de hasta 1.5A.\n\nCaracterísticas Técnicas:\nTipo de Regulador: Fijo\nVoltaje de Entrada: 7V a 35V\nVoltaje de Salida: 5V\nCorriente Máxima de Salida: 1.5A\nProtección Contra Cortocircuitos: Incorporada para proteger tus circuitos\nTemperatura de Operación: -40°C a +125°C\nCompensación de Térmica: Garantiza estabilidad y precisión en un amplio rango de temperaturas\nAplicaciones:\nFuentes de alimentación para circuitos integrados\nSistemas de carga de baterías\nElectrónica de consumo y equipos industriales\nVentajas del Producto:\nAlta Fiabilidad: Fabricado con estándares de calidad para asegurar un rendimiento óptimo\nEstabilidad de Voltaje: Proporciona un voltaje constante de 5V, ideal para una amplia gama de aplicaciones\nProtección y Seguridad: Incluye protección contra sobrecargas y cortocircuitos",
        "code": "",
        "datasheet": false
    },
    {
        "id": 105,
        "name": "Pack de 10 Sensores Táctiles Capacitivos TTP223 Módulo Rojo",
        "price": "240",
        "quantity": 10,
        "images": [
            "Imagenes/105/105_1.jpg",
            "Imagenes/105/105_2.jpg",
            "Imagenes/105/105_3.jpg"
        ],
        "description": "Descripción Detallada Eléctrica\nCaracterísticas:\n\nModelo: TTP223\nTipo de Sensor: Sensor Táctil Capacitivo\nCantidad: Pack de 10 módulos\nVoltaje de Operación (VCC): 2.0V a 5.5V\nConsumo de Corriente: Baja corriente de reposo < 1.5µA\nSalida: Alta a 5V y baja a 0V\nTiempo de Respuesta: ~220 ms en modo táctil y ~60 ms en modo rápido\nTemperatura de Operación: -30°C a 70°C\nInterfaz: 3 pines (VCC, GND, I/O)\nDimensiones: 11mm x 15mm\nDescripción:\n\nEl TTP223 es un módulo sensor táctil capacitivo que utiliza la tecnología táctil capacitiva para detectar la proximidad y el toque. Este pack de 10 módulos es ideal para proyectos de electrónica que requieren una interfaz táctil simple y efectiva.\n\nConexiones:\n\nVCC: Conectar al voltaje de operación (2.0V - 5.5V)\nGND: Conectar a tierra\nI/O: Pin de salida digital, cambia de estado al detectar un toque\nAplicaciones:\n\nInterruptores táctiles para proyectos DIY\nReemplazo de botones mecánicos en dispositivos electrónicos\nControles táctiles en sistemas embebidos\nProyectos interactivos con Arduino y otras plataformas\nVentajas:\n\nAlta sensibilidad: Detecta toques ligeros con precisión\nBajo consumo de energía: Ideal para dispositivos portátiles y de bajo consumo\nCompacto y fácil de usar: Perfecto para integrarse en proyectos con espacio limitado\nModo de Operación:\nEl TTP223 opera en dos modos, el modo táctil normal y el modo rápido. En el modo táctil normal, el tiempo de respuesta es de aproximadamente 220 ms, adecuado para la mayoría de las aplicaciones táctiles. En el modo rápido, el tiempo de respuesta es de aproximadamente 60 ms, adecuado para aplicaciones que requieren una respuesta inmediata.",
        "code": "// Define el pin de entrada del sensor táctil\nconst int touchPin = 2; // Conectar el pin I/O del TTP223 al pin digital 2 del Arduino\nconst int ledPin = 13;  // Conectar un LED al pin digital 13 del Arduino (opcional)\n\nvoid setup() {\n  // Configura el pin del sensor táctil como entrada\n  pinMode(touchPin, INPUT);\n  // Configura el pin del LED como salida\n  pinMode(ledPin, OUTPUT);\n  // Inicializa la comunicación serial para el monitoreo\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // Lee el estado del sensor táctil\n  int touchState = digitalRead(touchPin);\n\n  // Si se detecta un toque\n  if (touchState == HIGH) {\n    // Enciende el LED\n    digitalWrite(ledPin, HIGH);\n    // Imprime un mensaje en el monitor serial\n    Serial.println(\"Tacto detectado\");\n  } else {\n    // Apaga el LED\n    digitalWrite(ledPin, LOW);\n  }\n\n  // Pequeña demora para evitar lecturas erróneas\n  delay(50);\n}",
        "datasheet": false
    },
    {
        "id": 106,
        "name": "Modulo ADC 16bit ADS1115 con Interfaz I2C y PGA",
        "price": "270",
        "quantity": 15,
        "images": [
            "Imagenes/106/106_1.jpg",
            "Imagenes/106/106_2.jpg",
            "Imagenes/106/106_3.jpg"
        ],
        "description": "Descripción Detallada Eléctrica\nCaracterísticas:\n\nModelo: ADS1115\nTipo de Convertidor: ADC (Analog to Digital Converter) de 16 bits\nInterfaz de Comunicación: I2C\nResolución: 16 bits\nRango de Voltaje de Entrada: 2.0V a 5.5V\nVoltaje de Referencia: Interna (2.048V) o externa\nFrecuencia de Reloj: 860 muestras por segundo (SPS) máx.\nGanancia Programable (PGA): 2/3x a 16x\nCanales de Entrada: 4 canales de entrada individuales o 2 diferenciales\nDirección I2C: Configurable, hasta 4 direcciones posibles\nConsumo de Corriente: Menos de 150µA en modo operativo, menos de 1µA en modo de apagado\nDimensiones: 25mm x 20mm\nConexiones:\n\nVDD: Alimentación (2.0V a 5.5V)\nGND: Tierra\nSCL: Línea de reloj del bus I2C\nSDA: Línea de datos del bus I2C\nADDR: Pin de selección de dirección I2C\nALRT: Pin de alerta\nA0, A1, A2, A3: Entradas analógicas\nDescripción:\n\nEl ADS1115 es un convertidor analógico a digital de 16 bits con interfaz I2C y amplificador de ganancia programable (PGA), ideal para aplicaciones que requieren alta resolución y precisión en la conversión de señales analógicas a digitales. Este módulo es capaz de medir señales analógicas desde cuatro canales individuales o dos diferenciales.\n\nAplicaciones Típicas:\n\nSensores Analógicos: Medición precisa de señales de sensores analógicos como temperatura, presión, luz, etc.\nAdquisición de Datos: Uso en sistemas de adquisición de datos donde se requiere alta resolución.\nInstrumentación: Aplicaciones de instrumentación que necesitan alta precisión y fiabilidad.\nAutomatización Industrial: Control y monitoreo en procesos industriales.\nVentajas:\n\nAlta Precisión: Con una resolución de 16 bits, el ADS1115 proporciona mediciones extremadamente precisas.\nInterfaz I2C: Facilita la comunicación con microcontroladores y otros dispositivos I2C.\nAmplificador de Ganancia Programable: Permite ajustar la ganancia para mejorar la precisión en mediciones de señales de bajo nivel.\nBajo Consumo de Energía: Ideal para aplicaciones alimentadas por baterías gracias a su bajo consumo de corriente.\nModo de Operación:\n\nEl ADS1115 puede configurarse para operar en modo continuo o modo de una sola toma. En modo continuo, realiza conversiones de forma continua a la frecuencia de muestreo seleccionada. En modo de una sola toma, realiza una conversión y luego entra en modo de apagado, reduciendo el consumo de energía.\n\nEste módulo es una excelente opción para proyectos de electrónica que requieren una conversión precisa y confiable de señales analógicas a digitales.",
        "code": "#include <Wire.h>\n#include <Adafruit_ADS1015.h>\n\n// Crear una instancia del ADS1115\nAdafruit_ADS1115 ads;\n\nvoid setup(void) {\n  Serial.begin(9600);\n  Serial.println(\"Inicializando ADS1115...\");\n\n  // Inicializar el ADS1115\n  ads.begin();\n}\n\nvoid loop(void) {\n  // Leer valores de los cuatro canales\n  int16_t adc0, adc1, adc2, adc3;\n\n  adc0 = ads.readADC_SingleEnded(0);\n  adc1 = ads.readADC_SingleEnded(1);\n  adc2 = ads.readADC_SingleEnded(2);\n  adc3 = ads.readADC_SingleEnded(3);\n\n  // Convertir los valores a voltaje\n  float volts0, volts1, volts2, volts3;\n  \n  volts0 = adc0 * 0.1875 / 1000;\n  volts1 = adc1 * 0.1875 / 1000;\n  volts2 = adc2 * 0.1875 / 1000;\n  volts3 = adc3 * 0.1875 / 1000;\n\n  // Imprimir los valores leídos en el monitor serie\n  Serial.print(\"ADC0: \"); Serial.print(adc0); Serial.print(\" | Voltaje0: \"); Serial.print(volts0); Serial.println(\" V\");\n  Serial.print(\"ADC1: \"); Serial.print(adc1); Serial.print(\" | Voltaje1: \"); Serial.print(volts1); Serial.println(\" V\");\n  Serial.print(\"ADC2: \"); Serial.print(adc2); Serial.print(\" | Voltaje2: \"); Serial.print(volts2); Serial.println(\" V\");\n  Serial.print(\"ADC3: \"); Serial.print(adc3); Serial.print(\" | Voltaje3: \"); Serial.print(volts3); Serial.println(\" V\");\n\n  Serial.println(\"---------------------------------------------------\");\n\n  // Pequeña demora antes de la próxima lectura\n  delay(1000);\n}",
        "datasheet": false
    },
    {
        "id": 107,
        "name": "Módulo Multiplexor 16 Canales CD74HC4067",
        "price": "180",
        "quantity": 30,
        "images": [
            "Imagenes/107/107_1.jpg",
            "Imagenes/107/107_2.jpg",
            "Imagenes/107/107_3.jpg",
            "Imagenes/107/107_4.jpg",
            "Imagenes/107/107_5.jpg",
            "Imagenes/107/107_6.jpg"
        ],
        "description": "Descripción Detallada Eléctrica\nCaracterísticas:\n\nModelo: CD74HC4067\nTipo de Componente: Multiplexor/Desmultiplexor Analógico-Digital de 16 Canales\nVoltaje de Operación (VCC): 2V a 6V\nCorriente de Operación: Máximo 1µA a 6V\nRango de Temperatura de Operación: -55°C a 125°C\nResistencia en Estado ON (Ron): 70 ohmios a 5V\nTiempo de Propagación: 14 ns a 5V\nConfiguración de Pines:\nS0, S1, S2, S3: Pines de selección de canal\nEN: Pin de habilitación (activo en bajo)\nSIG: Pin común para la señal multiplexada\nC0-C15: 16 canales de entrada/salida\nVCC: Voltaje de alimentación\nGND: Tierra\nDimensiones: 35mm x 25mm\nDescripción:\n\nEl CD74HC4067 es un multiplexor/demultiplexor analógico-digital de alta velocidad con 16 canales de entrada/salida que se pueden controlar mediante una interfaz de selección de 4 bits. Este módulo es ideal para expandir las entradas y salidas de tu microcontrolador, permitiendo la conexión de múltiples sensores, interruptores o señales a un solo pin de entrada/salida.\n\nAplicaciones Típicas:\n\nExpansión de Entradas/Salidas: Ideal para proyectos que requieren la conexión de múltiples dispositivos a un solo microcontrolador.\nAdquisición de Datos: Permite la lectura de múltiples sensores analógicos con un solo pin de entrada.\nSelección de Señales: Útil en sistemas de conmutación de señales analógicas y digitales.\nAutomatización: Control de múltiples dispositivos en proyectos de automatización y robótica.\nVentajas:\n\nAlta Velocidad: Tiempo de propagación rápido, adecuado para aplicaciones que requieren cambios rápidos de canal.\nBajo Consumo de Energía: Ideal para proyectos alimentados por batería.\nBaja Resistencia ON: Proporciona una baja pérdida de señal.\nCompatibilidad: Compatible con una amplia gama de microcontroladores.",
        "code": "#include <Arduino.h>\n\n// Definir los pines de selección del canal\nconst int s0 = 2;\nconst int s1 = 3;\nconst int s2 = 4;\nconst int s3 = 5;\n\n// Definir el pin de habilitación (activo en bajo)\nconst int en = 6;\n\n// Definir el pin de señal común\nconst int sig = A0;\n\nvoid setup() {\n  // Configurar los pines de selección y habilitación como salidas\n  pinMode(s0, OUTPUT);\n  pinMode(s1, OUTPUT);\n  pinMode(s2, OUTPUT);\n  pinMode(s3, OUTPUT);\n  pinMode(en, OUTPUT);\n\n  // Configurar el pin de señal como entrada\n  pinMode(sig, INPUT);\n\n  // Deshabilitar el multiplexor inicialmente\n  digitalWrite(en, HIGH);\n\n  // Iniciar la comunicación serie para el monitoreo\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // Habilitar el multiplexor\n  digitalWrite(en, LOW);\n\n  // Leer cada uno de los 16 canales\n  for (int channel = 0; channel < 16; channel++) {\n    // Seleccionar el canal configurando los pines de selección\n    digitalWrite(s0, channel & 0x01);\n    digitalWrite(s1, (channel >> 1) & 0x01);\n    digitalWrite(s2, (channel >> 2) & 0x01);\n    digitalWrite(s3, (channel >> 3) & 0x01);\n\n    // Leer el valor analógico del canal seleccionado\n    int value = analogRead(sig);\n\n    // Imprimir el canal y el valor leído\n    Serial.print(\"Canal \");\n    Serial.print(channel);\n    Serial.print(\": \");\n    Serial.println(value);\n\n    // Esperar un poco antes de leer el siguiente canal\n    delay(100);\n  }\n\n  // Deshabilitar el multiplexor para ahorrar energía\n  digitalWrite(en, HIGH);\n\n  // Esperar un segundo antes de la siguiente lectura\n  delay(1000);\n}",
        "datasheet": false
    },
    {
        "id": 108,
        "name": "Transistor MOSFET de Potencia IRFP250N N-Channel 200V 30A",
        "price": "150",
        "quantity": 15,
        "images": [
            "Imagenes/108/108_1.jpg",
            "Imagenes/108/108_2.jpg"
        ],
        "description": "Descripción Detallada Eléctrica\nCaracterísticas:\n\nModelo: IRFP250N\nTipo de Transistor: MOSFET de Potencia de Canal N\nVoltaje de Drenaje-Fuente (Vds): 200V\nCorriente de Drenaje (Id): 30A\nVoltaje de Puerta-Umbral (Vgs(th)): 2V - 4V\nResistencia de Encendido (Rds(on)): 0.075 ohmios\nCapacidad de Carga de la Puerta (Qg): 230nC\nDisipación de Potencia (Pd): 200W\nTemperatura de Operación: -55°C a 175°C\nEncapsulado: TO-247\nDescripción:\n\nEl IRFP250N es un transistor MOSFET de potencia de canal N, diseñado para manejar altas corrientes y voltajes, ideal para aplicaciones de conmutación y amplificación de potencia. Este MOSFET es conocido por su baja resistencia de encendido, alta capacidad de manejo de corriente y rápida velocidad de conmutación, lo que lo hace adecuado para diversas aplicaciones electrónicas de alta potencia.\n\nAplicaciones Típicas:\n\nFuentes de Alimentación Conmutadas: Utilizado en fuentes de alimentación conmutadas (SMPS) debido a su alta eficiencia y capacidad de manejo de potencia.\nControl de Motores: Adecuado para aplicaciones de control de motores en sistemas de automatización y robótica.\nAmplificadores de Potencia: Utilizado en amplificadores de audio de alta potencia y otros sistemas de amplificación.\nInversores y Convertidores: Ideal para inversores de energía y convertidores DC-DC.\nProtección de Sobrecorriente: Aplicado en circuitos de protección para evitar daños por sobrecorriente.\nVentajas:\n\nBaja Resistencia de Encendido: Minimiza las pérdidas de conducción, aumentando la eficiencia del circuito.\nAlta Capacidad de Manejo de Corriente: Capaz de manejar hasta 30A, adecuado para aplicaciones de alta corriente.\nRápida Velocidad de Conmutación: Reduce las pérdidas de conmutación, mejorando la eficiencia energética.\nAlta Disipación de Potencia: Puede disipar hasta 200W, proporcionando una mayor fiabilidad en aplicaciones de alta potencia.\nConexiones:\nDrenaje (Drain): Conectar al voltaje de carga\nFuente (Source): Conectar a tierra\nPuerta (Gate): Conectar al controlador de señal",
        "code": "",
        "datasheet": false
    },
    {
        "id": 109,
        "name": "Pack de 100 leds 5mm surtidos",
        "price": "260",
        "quantity": 19,
        "images": [
            "Imagenes/109/109_1.jpg",
            "Imagenes/109/109_2.jpg",
            "Imagenes/109/109_3.jpg",
            "Imagenes/109/109_4.jpg",
            "Imagenes/109/109_5.jpg",
            "Imagenes/109/109_6.jpg"
        ],
        "description": "Parámetro:\nCorriente de funcionamiento: 20 (mA)\n \nVoltaje de trabajo:\nRojo: 1,9 V-2,1 V\nAmarillo: 1,9 V-2,1 V\nVerde: 1,9 V-2,1 V\nAzul: 3,0 V-3,2 V\nBlanco: 3,0 V-3,2 V\n \nMCD:\nRojo: 600-800\nAmarillo: 600-800\nVerde: 600-800\nAzul: 1000-1200\nBlanco: 14000-16000\n \nLongitud de onda:\nRojo: 620-625\nAmarillo: 590-592\nVerde: 567-570\nAzul: 460-465\nBlanco: Color temperatura 8000",
        "code": "",
        "datasheet": false
    },
    {
        "id": 110,
        "name": "Sensor de Color TCS34725 RGB con LED Integrado I2C",
        "price": "440",
        "quantity": 10,
        "images": [
            "Imagenes/110/110_1.jpg",
            "Imagenes/110/110_10.jpg",
            "Imagenes/110/110_11.jpg",
            "Imagenes/110/110_12.jpg",
            "Imagenes/110/110_13.jpg",
            "Imagenes/110/110_2.jpg",
            "Imagenes/110/110_3.jpg",
            "Imagenes/110/110_4.jpg",
            "Imagenes/110/110_5.jpg",
            "Imagenes/110/110_6.jpg",
            "Imagenes/110/110_7.jpg",
            "Imagenes/110/110_8.jpg",
            "Imagenes/110/110_9.jpg"
        ],
        "description": "Descripción eléctrica detallada:\nEl TCS34725 es un sensor de color RGB (rojo, verde y azul) con un filtro IR integrado y un LED blanco incorporado. Este sensor es capaz de detectar la intensidad de la luz en las bandas roja, verde, azul y clara, lo que lo hace ideal para aplicaciones de detección de color y medición de luz ambiental.\n\nEspecificaciones eléctricas:\n\nVoltaje de operación: 3.3V a 5V, lo que lo hace compatible con la mayoría de los microcontroladores como Arduino y Raspberry Pi.\nInterfaz: Utiliza la comunicación I2C para interactuar con un microcontrolador. Los pines SDA y SCL se utilizan para transmitir datos y sincronización, respectivamente.\nPines de conexión:\nVIN: Entrada de voltaje (3.3V a 5V).\nGND: Tierra.\n3V3: Salida de 3.3V (puede ser utilizada para alimentar otros dispositivos).\nSCL: Reloj de la interfaz I2C.\nSDA: Línea de datos de la interfaz I2C.\nINT: Pin de interrupción para señalizar eventos específicos.\nLED: Control de encendido del LED integrado para iluminación del objeto a detectar.\nLED Integrado: Un LED blanco de alta intensidad que se puede controlar a través del pin LED, proporcionando una fuente de luz constante para la detección de colores en condiciones de iluminación variables.\nResolución: El sensor tiene una resolución de 16 bits, lo que permite una detección de colores precisa y detallada.\nFiltro IR: El filtro infrarrojo integrado elimina las interferencias de luz infrarroja, asegurando una medición más precisa de los colores.\nEl TCS34725 es ideal para aplicaciones como reconocimiento de color, calibración de monitores, detección de luz ambiental, y otras aplicaciones que requieran una medición precisa del color y la luz. Además, su fácil integración mediante I2C lo convierte en una opción flexible para diversos proyectos de electrónica.",
        "code": "#include <Wire.h>\n#include \"Adafruit_TCS34725.h\"\n\n// Inicializa el sensor TCS34725\nAdafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);\n\nvoid setup() {\n  Serial.begin(9600);\n  if (tcs.begin()) {\n    Serial.println(\"TCS34725 sensor found.\");\n  } else {\n    Serial.println(\"No TCS34725 sensor found ... check your wiring.\");\n    while (1); // Halt\n  }\n\n  // Opcional: Apagar el LED\n  // tcs.setInterrupt(true);\n}\n\nvoid loop() {\n  uint16_t r, g, b, c;\n  \n  // Leer valores de color\n  tcs.getRawData(&r, &g, &b, &c);\n\n  // Imprimir valores de color en el monitor serie\n  Serial.print(\"Rojo: \"); Serial.print(r, DEC);\n  Serial.print(\" Verde: \"); Serial.print(g, DEC);\n  Serial.print(\" Azul: \"); Serial.print(b, DEC);\n  Serial.print(\" Claro: \"); Serial.println(c, DEC);\n\n  // Convertir a valores RGB (con corrección de gamma)\n  uint32_t sum = r + g + b;\n  float red, green, blue;\n  red = r; red /= sum;\n  green = g; green /= sum;\n  blue = b; blue /= sum;\n\n  red *= 256; green *= 256; blue *= 256;\n\n  Serial.print(\"RGB Values (Corrected): \");\n  Serial.print((int)red); Serial.print(\", \");\n  Serial.print((int)green); Serial.print(\", \");\n  Serial.print((int)blue); Serial.println(\" \");\n\n  // Pausa para leer los valores\n  delay(1000);\n}",
        "datasheet": false
    },
    {
        "id": 112,
        "name": "Módulo Cargador de Batería 134N3P con Micro USB y Salida USB",
        "price": "90",
        "quantity": 19,
        "images": [
            "Imagenes/112/112_1.jpg",
            "Imagenes/112/112_2.jpg",
            "Imagenes/112/112_3.jpg",
            "Imagenes/112/112_4.jpg",
            "Imagenes/112/112_5.jpg"
        ],
        "description": "Descripción detallada:\nEl módulo 134N3P es un cargador de batería diseñado para celdas de litio con una interfaz Micro USB para la entrada de carga y un puerto USB estándar para la salida de energía. Este módulo es ideal para aplicaciones en sistemas portátiles, bancos de energía (power banks), y dispositivos electrónicos DIY.\n\nCaracterísticas eléctricas:\n\nEntrada: Micro USB (5V DC)\nSalida: Puerto USB estándar (5V DC, 1A máx.)\nCorriente de carga: Hasta 1A (dependiendo de la batería conectada)\nVoltaje de carga completo: 4.2V (para baterías de litio)\nProtecciones: Protección contra sobrecarga, descarga, sobrecorriente y cortocircuito.\nIndicadores LED: Indicación de carga y carga completa\nAplicaciones:\n\nCargadores de baterías portátiles\nProyectos de energía móvil DIY\nDispositivos electrónicos que requieren una fuente de alimentación USB regulada\nEste módulo 134N3P con entrada Micro USB es perfecto para proyectos que requieren una solución de carga eficiente y segura para baterías de litio, proporcionando una salida regulada para alimentar o recargar dispositivos mediante USB.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 113,
        "name": "Pack de 5 Transistores NPN TIP41C 100V 6A",
        "price": "180",
        "quantity": 12,
        "images": [
            "Imagenes/113/113_1.jpg",
            "Imagenes/113/113_2.jpg"
        ],
        "description": "Este pack incluye 5 transistores NPN TIP41C de potencia media en encapsulado TO-220. Estos transistores son ampliamente utilizados en aplicaciones de amplificación y conmutación debido a su capacidad de manejar altas corrientes y voltajes. Son ideales para controles de motores, fuentes de alimentación, reguladores de voltaje y otros circuitos de potencia.\n\nCaracterísticas eléctricas:\n\nTipo de transistor: NPN\nVoltaje colector-emisor (Vce): 100V\nCorriente de colector (Ic): 6A\nPotencia máxima (Pd): 65W\nGanancia de corriente continua (hFE): 15 a 75 (depende de Ic)\nVoltaje base-emisor (Vbe): 1.2V (máx)\nEncapsulado: TO-220\nCantidad: 5 unidades\nAplicaciones:\n\nAmplificadores de audio\nCircuitos de conmutación de media potencia\nControladores de motores\nReguladores de voltaje lineales\nEste pack de 5 transistores TIP41C es ideal para proyectos que requieren control de corriente de media a alta potencia, ofreciendo una solución robusta y confiable en un encapsulado de fácil montaje.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 114,
        "name": "Transistor IGBT RJH60F5 600V 60A en Encapsulado TO-247",
        "price": "360",
        "quantity": 24,
        "images": [
            "Imagenes/114/114_1.jpg",
            "Imagenes/114/114_2.jpg"
        ],
        "description": "Descripción detallada:\nEl RJH60F5 es un transistor IGBT (Insulated Gate Bipolar Transistor) diseñado para manejar altos voltajes y corrientes, ideal para aplicaciones de conmutación de alta potencia como inversores, fuentes de alimentación conmutadas, y controladores de motor. Este transistor combina las ventajas de la rápida conmutación de un MOSFET con la baja caída de voltaje de un transistor bipolar, ofreciendo alta eficiencia y robustez en un encapsulado TO-247.\n\nCaracterísticas eléctricas:\n\nTipo de transistor: IGBT\nVoltaje de colector-emisor (Vce): 600V\nCorriente de colector (Ic): 60A\nPotencia máxima (Pd): 150W\nVoltaje de puerta-emisor (Vge): ±20V\nEncapsulado: TO-247\nAplicaciones:\n\nInversores de potencia\nControladores de motor\nFuentes de alimentación conmutadas\nConvertidores de energía\nEste transistor IGBT RJH60F5 es ideal para proyectos y aplicaciones que requieren un manejo eficiente y confiable de altas corrientes y voltajes, proporcionando una solución robusta y eficiente en un encapsulado de fácil montaje.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 115,
        "name": "Pack de 2 Transistores MOSFET IRF640N 200V 18A en Encapsulado TO-220",
        "price": "160",
        "quantity": 12,
        "images": [
            "Imagenes/115/115_1.jpg",
            "Imagenes/115/115_2.jpg",
            "Imagenes/115/115_3.jpg",
            "Imagenes/115/115_4.jpg"
        ],
        "description": "Este pack incluye 2 transistores MOSFET IRF640N de canal N, diseñados para aplicaciones de conmutación de alta eficiencia. Cada MOSFET ofrece una baja resistencia en estado de encendido (Rds(on)) y es capaz de manejar corrientes de hasta 18A y voltajes de hasta 200V, lo que los convierte en una excelente opción para controladores de motor, fuentes de alimentación conmutadas, y otras aplicaciones de conmutación de alta potencia.\n\nCaracterísticas eléctricas:\n\nTipo de transistor: MOSFET de canal N\nVoltaje de drenaje-fuente (Vds): 200V\nCorriente de drenaje (Id): 18A\nResistencia en estado de encendido (Rds(on)): 0.18 ohmios\nVoltaje de compuerta-umbral (Vgs(th)): 2.0V a 4.0V\nEncapsulado: TO-220\nCantidad: 2 unidades\nAplicaciones:\n\nFuentes de alimentación conmutadas (SMPS)\nControladores de motor\nConvertidores de potencia DC-DC\nAmplificadores de clase D\nEste pack de 2 MOSFETs IRF640N es ideal para proyectos que requieren conmutación rápida y eficiente en aplicaciones de alta potencia, ofreciendo una solución robusta y confiable en un encapsulado TO-220.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 116,
        "name": "Programador St-link V2 Para Stm32/stm8 (con Cables)",
        "price": "380",
        "quantity": 4,
        "images": [
            "Imagenes/116/116_1.jpg",
            "Imagenes/116/116_2.jpg",
            "Imagenes/116/116_3.jpg",
            "Imagenes/116/116_4.jpg",
            "Imagenes/116/116_5.jpg"
        ],
        "description": "Descripción detallada eléctrica:\nEl ST-Link V2 es un programador y depurador de alta velocidad diseñado para microcontroladores STM32 y STM8. Funciona a un voltaje de entrada de 5V proporcionado a través del puerto USB. El dispositivo soporta voltajes de operación de 3.3V y 5V, seleccionables mediante un jumper. Además, incluye señales de entrada/salida como SWIM (Single Wire Interface Module) para STM8 y SWD (Serial Wire Debug) para STM32, con las respectivas líneas de datos y reloj. El ST-Link V2 se comunica con el microcontrolador a través de una interfaz JTAG/SWD, lo que permite la depuración en tiempo real, carga de firmware y monitoreo del estado del sistema.\n\nEl módulo incluye un conector de 10 pines con las siguientes señales:\n\nSWIM: Pin dedicado para la interfaz de programación de los microcontroladores STM8.\nSWDIO y SWCLK: Pines dedicados para la interfaz de depuración serie (SWD) de los microcontroladores STM32.\nGND: Conexión a tierra para garantizar un funcionamiento estable.\n3.3V/5V: Pines de salida para alimentar los circuitos de destino, según la configuración seleccionada.\nEste programador es compatible con diversas herramientas de desarrollo, como ST-Link Utility, Keil, IAR, y la plataforma Arduino, facilitando así la programación y depuración de tus proyectos electrónicos.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 117,
        "name": "Generador Pwm De 2 Canales Con Display Digital",
        "price": "290",
        "quantity": 6,
        "images": [
            "Imagenes/117/117_1.jpg",
            "Imagenes/117/117_2.jpg",
            "Imagenes/117/117_3.jpg",
            "Imagenes/117/117_4.jpg"
        ],
        "description": "Descripción del Producto:\n\nEste generador PWM (Modulación por Ancho de Pulso) de 2 canales es una herramienta versátil y compacta ideal para aplicaciones de control de motores, luces LED, o cualquier dispositivo que requiera señales PWM precisas. Con su pantalla digital clara y fácil de leer, permite ajustar la frecuencia y el ciclo de trabajo de cada canal de forma independiente.\n\nCaracterísticas:\n\nAlimentación: 3.3V a 5.5V a través de micro USB o terminales VIN+ y GND.\nFrecuencia de Salida: Ajustable entre 1Hz y 150KHz, con alta precisión.\nCiclo de Trabajo: Ajustable entre 0% y 100%, permitiendo un control total sobre la potencia entregada a la carga.\nCanales Independientes: Dos canales PWM (PW1 y PW2) con salidas independientes.\nPantalla Digital: Muestra la frecuencia y el ciclo de trabajo actuales, facilitando el ajuste preciso en tiempo real.\nBotones de Control: Cuatro botones táctiles para una fácil navegación y configuración de los parámetros.\nTamaño Compacto: 43.5mm x 28.5mm, ideal para proyectos donde el espacio es limitado.\nAplicaciones:\n\nControl de velocidad de motores de corriente continua.\nRegulación de intensidad de luces LED.\nGeneración de señales para simulación de circuitos.\nControl de dispositivos electrónicos que requieren señales PWM.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 119,
        "name": "Placa BMS 3S 20A Protección para Baterías 18650 12.6V",
        "price": "180",
        "quantity": 12,
        "images": [
            "Imagenes/119/119_1.jpg",
            "Imagenes/119/119_2.jpg",
            "Imagenes/119/119_3.jpg",
            "Imagenes/119/119_4.jpg"
        ],
        "description": "Este módulo BMS (Sistema de Gestión de Baterías) 3S de 20A está diseñado para la protección de packs de baterías de iones de litio 18650 de 12,6V (tres celdas en serie). Ofrece una gestión completa que incluye protección contra sobrecarga, sobredescarga, sobrecorriente y cortocircuito. Incorpora MOSFET de alta calidad para un control eficiente de la corriente, asegurando que la carga se detenga automáticamente cuando se alcanza el voltaje de corte (4,2V por celda), y reanudando la carga cuando se detecta una caída en el voltaje. Es ideal para aplicaciones en sistemas de respaldo, equipos electrónicos y vehículos eléctricos pequeños, protegiendo las baterías de manera segura y eficiente.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 120,
        "name": "Amplificador Audio Digital TPA3110 60W 8-24V",
        "price": "350",
        "quantity": 10,
        "images": [
            "Imagenes/120/120_1.jpg",
            "Imagenes/120/120_2.jpg",
            "Imagenes/120/120_3.jpg",
            "Imagenes/120/120_4.jpg",
            "Imagenes/120/120_5.jpg"
        ],
        "description": "Este módulo amplificador de audio digital basado en el chip TPA3110 es ideal para proyectos de sonido DIY, Arduino y sistemas de audio personalizados. Ofrece una salida de hasta 60W en configuración PBTL (Puenteado Mono) y es compatible con altavoces de 4 a 8 ohmios, proporcionando una excelente calidad de sonido con baja distorsión.\n\nEspecificaciones Técnicas:\nChip Amplificador: TPA3110.\nPotencia de Salida: Hasta 60W a 8 ohmios.\nVoltaje de Operación: DC 8V a 24V.\nImpedancia de Altavoz Compatible: 4-8 ohmios.\nRango de Frecuencia: 20Hz - 20kHz.\nEficiencia: Alta eficiencia hasta un 90%, ideal para aplicaciones portátiles y de bajo consumo.\nCaracterísticas:\nProtección Integrada: El módulo incluye protección contra cortocircuito, sobrecalentamiento y sobrecarga, lo que garantiza una operación segura y confiable.\nConfiguración PBTL: Permite una configuración puenteada que maximiza la potencia de salida en una sola salida mono.\nComponentes de Alta Calidad: Capacitores de 330uF/35V y bobinas de filtro que minimizan la interferencia de ruido para una reproducción de sonido limpia.\nCompatibilidad Versátil: Se puede integrar fácilmente con microcontroladores como Arduino, Raspberry Pi y otros sistemas de control, facilitando la creación de proyectos de audio personalizados.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 121,
        "name": "Puntero laser ajustable 5V 650nm",
        "price": "70",
        "quantity": 100,
        "images": [
            "Imagenes/121/121_1.jpg",
            "Imagenes/121/121_2.jpg",
            "Imagenes/121/121_3.jpg",
            "Imagenes/121/121_4.jpg",
            "Imagenes/121/121_5.jpg"
        ],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 122,
        "name": "Placa Matriz De Puntos Led 8 x 8, Max721 (con Cables)",
        "price": "290",
        "quantity": 15,
        "images": [
            "Imagenes/122/122_1.jpg"
        ],
        "description": "El Módulo de Matriz de Puntos MAX7219 es un dispositivo que permite controlar una matriz de LEDs de manera sencilla y eficiente mediante un solo chip controlador. Es ampliamente utilizado en proyectos de Arduino, microcontroladores y otros sistemas embebidos debido a su capacidad para manejar múltiples matrices de LEDs con un mínimo de pines de control.\n\nCaracterísticas Principales:\nControlador Integrado MAX7219: Este módulo utiliza el chip MAX7219, un controlador de matriz de puntos con interfaz serial que facilita la gestión de hasta 64 LEDs con un solo chip. Permite controlar matrices de 8x8, barras de LED o displays de 7 segmentos.\n\nFácil Interfaz Serial: El módulo se comunica mediante una interfaz SPI (Serial Peripheral Interface), lo que permite la conexión sencilla con microcontroladores usando solo 3 pines: DIN (Datos), CS (Chip Select), y CLK (Reloj).\n\nMultiplexado Dinámico: El MAX7219 se encarga del multiplexado y corriente de los LEDs, proporcionando una corriente constante a cada LED y asegurando un brillo uniforme sin necesidad de componentes adicionales.\n\nControl de Brillo Programable: El brillo de los LEDs se puede ajustar mediante comandos seriales, permitiendo un control fino de la intensidad luminosa.\n\nConexión en Cascada: Es posible conectar múltiples módulos en cascada, ampliando la capacidad del sistema para controlar varias matrices de LEDs al mismo tiempo. Esto es ideal para crear displays más grandes o complejos.\n\nCompatibilidad Amplia: Funciona con múltiples plataformas de desarrollo como Arduino, ESP32, Raspberry Pi, entre otros, y es compatible con librerías ampliamente utilizadas que simplifican la programación y control del display.\n\nEspecificaciones Técnicas:\nVoltaje de Operación: 5V DC.\nCorriente de Operación: 320 mA (máx.) dependiendo de la cantidad de LEDs encendidos.\nDimensiones del Módulo: Aproximadamente 32 mm x 32 mm x 15 mm.\nConfiguración del Display: Matriz de 8x8 LEDs (64 LEDs en total).\nControl de Brillo: 16 niveles de intensidad ajustables.\nProtección Integrada: Incluye resistencias de corriente internas y una protección contra sobrecorriente para evitar daños en los LEDs.\nAplicaciones Comunes:\nRelojes digitales y temporizadores.\nPantallas de texto y gráficos.\nIndicadores y paneles de información.\nProyectos de visualización interactiva y juegos.",
        "code": "#include <LedControl.h>\n\n// Configuración de pines (adaptar según tus conexiones)\n#define DIN_PIN 23  // Pin de datos (DIN) conectado al módulo MAX7219\n#define CS_PIN 5    // Pin de carga (CS) conectado al módulo MAX7219\n#define CLK_PIN 18  // Pin de reloj (CLK) conectado al módulo MAX7219\n\n// Inicializa el control de LEDs con LedControl (DIN, CLK, CS, número de dispositivos)\nLedControl lc = LedControl(DIN_PIN, CLK_PIN, CS_PIN, 1);  // Cambia 1 por la cantidad de módulos si usas más\n\nvoid setup() {\n  // Inicializa el módulo MAX7219\n  lc.shutdown(0, false);      // Desactiva el modo de apagado\n  lc.setIntensity(0, 8);      // Configura la intensidad del brillo (0-15)\n  lc.clearDisplay(0);         // Limpia la pantalla al inicio\n  \n  // Ejemplo: muestra un patrón de punto en la matriz\n  displayPattern();\n}\n\nvoid loop() {\n  // Ejemplo: Rota un punto de luz en la matriz\n  for (int i = 0; i < 8; i++) {\n    lc.setLed(0, i, i, true);  // Enciende el LED en la posición (fila, columna)\n    delay(100);\n    lc.setLed(0, i, i, false); // Apaga el LED\n  }\n}\n\n// Función para mostrar un patrón predefinido en la matriz\nvoid displayPattern() {\n  // Define un patrón de 8x8 (por ejemplo, una sonrisa)\n  byte pattern[8] = {\n    0b00111100,\n    0b01000010,\n    0b10100101,\n    0b10000001,\n    0b10100101,\n    0b10011001,\n    0b01000010,\n    0b00111100\n  };\n\n  // Muestra el patrón en la matriz\n  for (int i = 0; i < 8; i++) {\n    lc.setRow(0, i, pattern[i]);\n  }\n}",
        "datasheet": false
    },
    {
        "id": 123,
        "name": "Placa Amplificador Digital Mono 100w Rms - Tpa3116d2 24vdc",
        "price": "690",
        "quantity": 10,
        "images": [
            "Imagenes/123/123_1.jpg",
            "Imagenes/123/123_2.jpg",
            "Imagenes/123/123_3.jpg",
            "Imagenes/123/123_4.jpg",
            "Imagenes/123/123_5.jpg"
        ],
        "description": "Descripción Eléctrica Detallada del Módulo Amplificador TPA3116D2:\nChip Principal:\n\nUtiliza el TPA3116D2, un amplificador clase D de Texas Instruments, altamente eficiente y de baja distorsión. Este chip es ideal para amplificación de audio en aplicaciones que requieren alta calidad de sonido y eficiencia energética.\nPotencia de Salida:\n\nProporciona hasta 100W de salida en modo mono, lo cual es adecuado para alimentar altavoces grandes con alta potencia y claridad.\nRango de Voltaje de Entrada:\n\nFunciona con una fuente de alimentación DC de entre 12V y 24V, siendo 24V el nivel óptimo para obtener la máxima potencia de salida. Es esencial usar una fuente de alimentación estable para evitar daños en el módulo.\nImpedancia de Salida:\n\nEs compatible con altavoces de 4 a 8, ajustándose mejor a altavoces de 4 para alcanzar su potencia máxima.\nCapacitores de Alta Capacidad:\n\nIncorpora capacitores de filtrado de alta capacidad que ayudan a suavizar la señal de audio y a reducir el ruido, mejorando la calidad del sonido.\nDisipación de Calor:\n\nIncluye un disipador de calor grande sobre el chip TPA3116D2, necesario para mantener la temperatura baja durante la operación continua a alta potencia, previniendo el sobrecalentamiento.\nProtecciones Integradas:\n\nEl chip TPA3116D2 incluye protecciones contra cortocircuito, sobrecarga térmica, y sobrevoltaje, lo cual protege tanto al amplificador como a los altavoces conectados.\nControl de Ganancia:\n\nEl módulo permite ajustes de ganancia para controlar el volumen y adaptar la salida a diferentes niveles de entrada y tipos de altavoces.\nAplicaciones:\n\nIdeal para sistemas de audio caseros, amplificadores portátiles, altavoces de bricolaje, y cualquier proyecto que requiera una amplificación de audio digital con alta eficiencia y potencia.\nConexiones:\n\nLas conexiones son generalmente mediante terminales de tornillo, lo cual facilita la conexión a fuentes de alimentación y altavoces.\nRecomendaciones de Uso:\nFuente de Alimentación: Utiliza una fuente de alimentación estable y con la capacidad de proveer suficiente corriente para evitar ruidos y posibles fallas.\nDisipación de Calor: Asegúrate de mantener el disipador limpio y bien ventilado para evitar sobrecalentamientos.\nProtecciones: A pesar de las protecciones integradas, siempre revisa la impedancia de los altavoces y la correcta polaridad de las conexiones para evitar daños.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 125,
        "name": "Microcontrolador Pic16f628a Dip-18 8 Bits",
        "price": "350",
        "quantity": 20,
        "images": [
            "Imagenes/125/125_1.jpg",
            "Imagenes/125/125_2.jpg",
            "Imagenes/125/125_3.jpg"
        ],
        "description": "El PIC16F628A es un microcontrolador CMOS de 8 bits de la familia PIC de Microchip, diseñado para ofrecer un alto rendimiento y flexibilidad en una amplia gama de aplicaciones electrónicas. Este modelo cuenta con memoria flash, lo que facilita la programación y reprogramación, ideal para desarrolladores y entusiastas de la electrónica que buscan un componente confiable y versátil.\n\nCaracterísticas Principales:\n\nArquitectura RISC: Cuenta con un diseño RISC de 35 instrucciones, lo que permite un procesamiento rápido y eficiente.\nMemoria Flash de 3.5 KB: Perfecta para almacenar el código del usuario, fácilmente programable mediante diversas herramientas de desarrollo.\nBajo Consumo de Energía: Diseñado para operaciones de bajo consumo, con modos de reposo para optimizar la eficiencia energética.\nVelocidad de Procesamiento: Hasta 20 MHz, adecuado para tareas que requieren respuesta rápida y confiabilidad.\nRAM y EEPROM Interna: Con 224 bytes de RAM y 128 bytes de EEPROM para almacenamiento de datos variables y configuración.\nMódulos Integrados: Incluye módulos PWM, comparadores, temporizadores y comunicación USART, ideales para aplicaciones de control y automatización.\nCompatibilidad: Encapsulado DIP-18, fácil de usar en protoboards y PCB, siendo una excelente opción para proyectos de aprendizaje y desarrollo.\nAplicaciones Típicas:\n\nSistemas de control y automatización\nProyectos DIY y educativos\nDesarrollo de prototipos electrónicos\nAplicaciones de robótica y automatización industrial\nVentajas:\n\nFácil de programar y reprogramar con herramientas de programación PIC estándar.\nAmplia documentación y soporte de la comunidad de desarrolladores de Microchip.\nVersatilidad en el uso gracias a su variedad de módulos integrados y opciones de configuración.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 127,
        "name": "Generador de Onda Sinusoidal, Cuadrada y Triangular AD9833",
        "price": "480",
        "quantity": 2,
        "images": [
            "Imagenes/127/127_1.jpg",
            "Imagenes/127/127_2.jpg",
            "Imagenes/127/127_3.jpg",
            "Imagenes/127/127_4.jpg"
        ],
        "description": "Descripción eléctrica detallada: El módulo AD9833 es un generador de señal de frecuencia programable mediante interfaz serial (SPI), ideal para aplicaciones que requieren generación de formas de onda como sinusoidal, cuadrada y triangular. Funciona con un rango de frecuencia desde 0 hasta 12.5 MHz, controlado por un microcontrolador o Arduino.\n\nEspecificaciones:\n\nVoltaje de operación: 2.3V a 5.5V\nConsumo de corriente: 20 mA (típico)\nInterfaz: Serial SPI\nTipos de onda generados: Sinusoidal, cuadrada y triangular\nRango de frecuencia: 0 a 12.5 MHz, ajustable mediante programación\nResolución de frecuencia: 28 bits, permitiendo pasos de frecuencia muy finos\nSalida: Señal analógica de baja distorsión",
        "code": "#include <SPI.h>\n\n// Pines de conexión\nconst int FSYNC = 10; // Pin FSYNC conectado a SS (Chip Select)\nconst int SPI_SPEED = 1000000; // Velocidad de comunicación SPI\n\nvoid setup() {\n  pinMode(FSYNC, OUTPUT);\n  SPI.begin();\n  SPI.beginTransaction(SPISettings(SPI_SPEED, MSBFIRST, SPI_MODE2));\n  digitalWrite(FSYNC, HIGH);\n\n  resetAD9833(); // Resetea el módulo\n  setFrequencyAD9833(1000); // Configura la frecuencia a 1 kHz\n  setWaveformAD9833(\"sinusoidal\"); // Configura la onda sinusoidal\n}\n\nvoid loop() {\n  // El loop se deja vacío ya que la configuración inicial sigue generando la onda continuamente\n}\n\n// Función para enviar comandos al AD9833\nvoid sendCommand(uint16_t command) {\n  digitalWrite(FSYNC, LOW);\n  SPI.transfer(highByte(command));\n  SPI.transfer(lowByte(command));\n  digitalWrite(FSYNC, HIGH);\n}\n\n// Resetea el AD9833\nvoid resetAD9833() {\n  sendCommand(0x0100); // Comando de reset\n}\n\n// Configura la frecuencia del AD9833\nvoid setFrequencyAD9833(uint32_t frequency) {\n  uint32_t freq_reg = (frequency * pow(2, 28)) / 25000000; // 25 MHz de reloj\n  uint16_t freq_low = freq_reg & 0x3FFF;\n  uint16_t freq_high = (freq_reg >> 14) & 0x3FFF;\n\n  sendCommand(0x2100); // Configura FREQ0 y PHASE0\n  sendCommand(0x4000 | freq_low); // Envía los bits bajos de frecuencia\n  sendCommand(0x4000 | freq_high); // Envía los bits altos de frecuencia\n  sendCommand(0x2000); // Sale del reset\n}\n\n// Configura el tipo de onda a generar\nvoid setWaveformAD9833(String waveform) {\n  if (waveform == \"sinusoidal\") {\n    sendCommand(0x2000); // Onda sinusoidal\n  } else if (waveform == \"cuadrada\") {\n    sendCommand(0x2028); // Onda cuadrada\n  } else if (waveform == \"triangular\") {\n    sendCommand(0x2002); // Onda triangular\n  }\n}",
        "datasheet": false
    },
    {
        "id": 129,
        "name": "Pro Mini ATmega168 5V/16MHz: Microcontrolador Compacto",
        "price": "350",
        "quantity": 3,
        "images": [
            "Imagenes/129/129_1.jpg",
            "Imagenes/129/129_2.jpg"
        ],
        "description": "Descripción Detallada Eléctrica:\nEl Pro Mini ATmega168 5V/16MHz es un microcontrolador basado en el chip ATmega168, diseñado para ofrecer la funcionalidad completa de un Arduino en un formato compacto y optimizado para proyectos que requieren un espacio reducido. Este módulo es ideal para aplicaciones de desarrollo rápido y prototipado, compatible con el entorno de Arduino IDE, ofreciendo una solución potente y económica para diversos proyectos electrónicos.\n\nEspecificaciones Técnicas:\n\nMicrocontrolador: ATmega168 o ATmega168P-AU.\nVoltaje de Funcionamiento: 5V.\nFrecuencia de Reloj: 16 MHz, proporcionando un rendimiento eficiente y estable para aplicaciones de tiempo real.\nMemoria Flash: 16 KB, de los cuales 2 KB son utilizados por el bootloader, dejando 14 KB disponibles para el usuario.\nSRAM: 1 KB, permitiendo el almacenamiento temporal de datos y el manejo de variables durante la ejecución del programa.\nEEPROM: 512 bytes, para almacenamiento de datos no volátiles, ideal para guardar configuraciones o datos que deban persistir entre reinicios.\nCantidad de Pines Digitales: 14, de los cuales 6 soportan salidas PWM, facilitando el control de motores, luces LED y otros dispositivos.\nEntradas Analógicas: 6 entradas con un rango de 0-5V, permitiendo la lectura precisa de sensores analógicos.\nCorriente Máxima por Pin I/O: 40 mA, asegurando compatibilidad con una amplia gama de sensores y actuadores.\nInterfaz de Comunicación: UART, SPI e I2C integrados, brindando múltiples opciones de conectividad para expansión y comunicación con otros módulos o microcontroladores.\nDimensiones: 18 mm x 33 mm, un diseño ultra compacto, adecuado para proyectos donde el espacio es un factor crucial.\nConsumo de Energía: Bajo consumo, ideal para proyectos portátiles y alimentados por batería.\nProgramación: Puede ser programado utilizando un adaptador USB-Serial (no incluido), compatible con software Arduino IDE.\nCaracterísticas Adicionales:\n\nFactor de forma reducido: Ideal para prototipos y proyectos finales que requieren un tamaño pequeño y bajo perfil.\nDiseño robusto: Componentes de alta calidad que aseguran un rendimiento confiable en ambientes exigentes.\nCompatible con Shields y módulos: Amplía las capacidades del Pro Mini mediante la integración con otros dispositivos y sensores.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 131,
        "name": "Módulo CAN Bus MCP2515 con TJA1050 para SPI",
        "price": "290",
        "quantity": 5,
        "images": [
            "Imagenes/131/131_1.jpg",
            "Imagenes/131/131_2.jpg",
            "Imagenes/131/131_3.jpg",
            "Imagenes/131/131_4.jpg"
        ],
        "description": "El Módulo CAN Bus MCP2515 con TJA1050 es una herramienta esencial para la comunicación CAN (Controller Area Network) utilizando microcontroladores con interfaz SPI como la ESP32, ARM o MCU 51. Este módulo facilita la conexión y el control de dispositivos en redes automotrices, industriales y sistemas de automatización, permitiendo una comunicación eficiente y confiable entre múltiples dispositivos.\n\nEspecificaciones Técnicas:\n\nChip Principal: MCP2515, controlador CAN con interfaz SPI para la gestión de la comunicación.\nReceptor y Transceptor: TJA1050, transceptor CAN de alta velocidad para una transmisión robusta y confiable.\nInterfaz de Comunicación: SPI (Serial Peripheral Interface), compatible con microcontroladores como Arduino, ESP32, STM32, y otros.\nVoltaje de Operación: 5V para la alimentación principal y 3.3V/5V para la lógica de comunicación.\nFrecuencia del Oscilador: 8 MHz, proporcionando un reloj preciso para la operación del MCP2515.\nCapacidades de Comunicación: Soporta el protocolo CAN 2.0B con velocidad de transferencia de hasta 1 Mb/s.\nConsumo de Energía: Bajo consumo, adecuado para aplicaciones donde la eficiencia energética es crítica.\nConectores de Entrada/Salida: Pines estándar y conectores terminales para una fácil conexión a otros módulos y sensores.\nAplicaciones Comunes: Redes automotrices, control industrial, automatización de edificios y sistemas embebidos.\nCaracterísticas Adicionales:\n\nAlta Inmunidad al Ruido: Diseño robusto que asegura una comunicación estable en entornos ruidosos.\nCompatibilidad Extensa: Funciona con múltiples plataformas de desarrollo, facilitando su integración en diferentes proyectos.\nProtección contra Sobretensiones y Cortocircuitos: Diseño seguro para una operación confiable y duradera.",
        "code": "#include <SPI.h>\n#include <mcp2515.h>\n\nstruct can_frame canMsg;\nMCP2515 mcp2515(5); // Definir el pin CS (Chip Select) para el MCP2515\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // Configurar el MCP2515\n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_500KBPS, MCP_8MHZ);\n  mcp2515.setNormalMode();\n\n  Serial.println(\"MCP2515 CAN Bus iniciado con éxito.\");\n}\n\nvoid loop() {\n  // Ejemplo de envío de mensaje CAN\n  canMsg.can_id  = 0x123; // Identificador del mensaje\n  canMsg.can_dlc = 8;     // Longitud del mensaje\n  canMsg.data[0] = 0x00;  // Datos del mensaje\n  canMsg.data[1] = 0x01;\n  canMsg.data[2] = 0x02;\n  canMsg.data[3] = 0x03;\n  canMsg.data[4] = 0x04;\n  canMsg.data[5] = 0x05;\n  canMsg.data[6] = 0x06;\n  canMsg.data[7] = 0x07;\n\n  mcp2515.sendMessage(&canMsg);\n  Serial.println(\"Mensaje CAN enviado.\");\n  \n  delay(1000); // Esperar 1 segundo\n}",
        "datasheet": false
    },
    {
        "id": 135,
        "name": "Generador de señal XR2206, salida sinusoidal/triangular/cuadrada",
        "price": "690",
        "quantity": 10,
        "images": [
            "Imagenes/135/135_1.jpg",
            "Imagenes/135/135_2.jpg",
            "Imagenes/135/135_3.jpg",
            "Imagenes/135/135_4.jpg",
            "Imagenes/135/135_5.jpg"
        ],
        "description": "Descripción eléctrica detallada:\nEste generador de señales basado en el IC XR2206 permite la creación de señales de salida sinusoidal, triangular y cuadrada con un rango de frecuencias ajustable entre 1 Hz y 1 MHz. La amplitud y frecuencia de la señal se pueden ajustar mediante potenciómetros.\n\nVoltaje de entrada: 9V ~ 12V DC\nTipo de señal de salida: Sinusoidal, Triangular, Cuadrada\nRango de frecuencia de salida: 1 Hz a 1 MHz (ajustable)\nAmplitud de señal: Ajustable hasta 3V (aproximado)\nResistencia de carga: 600 ohmios mín.\nCapacitores y resistencias clave: Los componentes pasivos presentes en el kit permiten el ajuste fino de la señal, controlando las curvas de las formas de onda.\nUsos: Generador de pruebas de señales para proyectos electrónicos, análisis de circuitos, pruebas de audiofrecuencia y más.",
        "code": "int potPin = A0;  // Pin del potenciómetro\nint outputPin = 9;  // Pin PWM para controlar el XR2206\nint potValue = 0;  // Valor leído del potenciómetro\nint freq = 0;  // Frecuencia ajustada\n\nvoid setup() {\n  pinMode(outputPin, OUTPUT);\n  Serial.begin(9600);  // Para monitorear la salida\n}\n\nvoid loop() {\n  potValue = analogRead(potPin);  // Lee el valor del potenciómetro\n  freq = map(potValue, 0, 1023, 1, 1000);  // Ajusta la frecuencia entre 1 Hz y 1000 Hz\n  tone(outputPin, freq);  // Genera la señal en la frecuencia ajustada\n  \n  Serial.print(\"Frecuencia: \");\n  Serial.println(freq);  // Imprime la frecuencia en el monitor serie\n  delay(100);\n}",
        "datasheet": false
    },
    {
        "id": 137,
        "name": "Amplificador audio TDA2030A  paquete x4",
        "price": "250",
        "quantity": 10,
        "images": [
            "Imagenes/137/137_1.jpg",
            "Imagenes/137/137_2.jpg",
            "Imagenes/137/137_3.jpg",
            "Imagenes/137/137_4.jpg",
            "Imagenes/137/137_5.jpg",
            "Imagenes/137/137_6.jpg"
        ],
        "description": "Descripción eléctrica detallada:\nEl TDA2030A es un amplificador de audio lineal de clase AB diseñado para aplicaciones de alta fidelidad. Proporciona una salida de hasta 18W (con ±18V) y cuenta con protección contra cortocircuitos y sobrecalentamiento, lo que garantiza un rendimiento estable y seguro en diversas aplicaciones.\n\nVoltaje de alimentación: ±9V a ±18V.\nCorriente de salida máxima: 3.5A.\nPotencia de salida: Hasta 18W (con ±18V y 4 ohmios).\nProtección térmica y contra cortocircuitos: El TDA2030A incluye protección integrada para evitar sobrecalentamientos y daños por cortocircuito.\nDistorsión armónica total: Menor al 0.5% en toda la gama de audiofrecuencia.\nGanancia de voltaje: 14 - 30 dB, configurable.\nPaquete: TO-220, adecuado para montaje en disipadores de calor.",
        "code": "int outputPin = 9;  // Pin PWM conectado a la entrada de audio del TDA2030A\n\nvoid setup() {\n  pinMode(outputPin, OUTPUT);\n}\n\nvoid loop() {\n  // Genera una señal de onda cuadrada para probar el amplificador\n  analogWrite(outputPin, 128);  // PWM al 50%\n  delay(500);\n  analogWrite(outputPin, 255);  // PWM al 100%\n  delay(500);\n}",
        "datasheet": false
    },
    {
        "id": 139,
        "name": "Pantalla OLED 0,91\" 128x32 I2C Blanco/Azul para Arduino",
        "price": "260",
        "quantity": 20,
        "images": [
            "Imagenes/139/139_1.jpg"
        ],
        "description": "Este módulo OLED de 0,91 pulgadas ofrece una resolución de 128x32 píxeles y utiliza una interfaz de comunicación I2C, lo que lo hace ideal para proyectos de Arduino y otras plataformas de microcontroladores. La pantalla OLED es eficiente en términos de energía, ofreciendo alta claridad en sus colores blanco o azul.\n\nResolución: 128x32 píxeles.\nTamaño de pantalla: 0,91 pulgadas.\nInterfaz de comunicación: I2C (IIC), soporta hasta 2 direcciones.\nVoltaje de alimentación: 3.3V ~ 5V.\nConsumo de corriente: Menos de 20 mA durante operación normal.\nColores: Blanco o azul (dependiendo del modelo).\nÁngulo de visión: Aproximadamente 160 grados.\nTipo de pantalla: OLED (diodo orgánico de emisión de luz), que no requiere retroiluminación, ahorrando energía.\nCompatibilidad: Compatible con Arduino, ESP32, Raspberry Pi y otros microcontroladores.\nTemperatura de funcionamiento: -40°C a +80°C.",
        "code": "#include <Wire.h>\n#include <U8g2lib.h>\n\n// Inicializa la pantalla OLED 128x32 con I2C\nU8G2_SSD1306_128X32_UNIVISION_F_SW_I2C u8g2(U8G2_R0, /* clock=*/ A5, /* data=*/ A4, /* reset=*/ U8X8_PIN_NONE); \n\nvoid setup() {\n  u8g2.begin();  // Inicia la pantalla\n}\n\nvoid loop() {\n  u8g2.clearBuffer();  // Limpia la pantalla\n  u8g2.setFont(u8g2_font_ncenB08_tr);  // Establece la fuente\n  u8g2.drawStr(0, 10, \"Hola Mundo!\");  // Muestra el texto en la pantalla\n  u8g2.sendBuffer();  // Envía el buffer a la pantalla\n  delay(1000);  // Espera 1 segundo\n}",
        "datasheet": false
    },
    {
        "id": 141,
        "name": "BTA12-600b (5 unidades)",
        "price": "350",
        "quantity": 15,
        "images": [],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 143,
        "name": "KBU1510 puente rectificador",
        "price": "100",
        "quantity": 7,
        "images": [],
        "description": "",
        "code": "",
        "datasheet": false
    },
    {
        "id": 147,
        "name": "Kit de Inicio ESP32 con Sensores y Prototipos",
        "price": "1900",
        "quantity": 4,
        "images": [
            "Imagenes/147/147_1.jpg",
            "Imagenes/147/147_2.jpg",
            "Imagenes/147/147_3.jpg"
        ],
        "description": "Kit de Inicio ESP32 con Sensores y Prototipos\n\nDescubre el mundo de la electrónica y la programación con este completo Kit de Inicio ESP32, ideal para principiantes y aficionados avanzados. Diseñado para facilitar el aprendizaje y la creación de proyectos innovadores, este kit incluye una amplia variedad de componentes esenciales, desde sensores hasta módulos de comunicación y displays, todo lo que necesitas para experimentar con el potente microcontrolador ESP32.\n\n¿Qué incluye este kit?\nESP32 WiFi + Bluetooth: Placa principal de desarrollo con un microcontrolador versátil y conectividad dual.\nPlaca Protoboard: Prototipado rápido sin soldaduras, ideal para ensamblar circuitos de prueba.\nConectores Jumper: Cables de conexión macho-macho para facilitar la interconexión de módulos.\nSensores Integrados:\nSensor PIR de Movimiento: Detecta la presencia de personas o animales mediante infrarrojos.\nSensor DHT11: Mide temperatura y humedad ambiental con alta precisión.\nSensor de Sonido: Captura cambios en el nivel de sonido, perfecto para proyectos interactivos.\nSensor de Obstáculos Infrarrojo: Detecta objetos y evita colisiones.\nPantalla OLED: Display de 0.96” para mostrar información en tiempo real, como datos de sensores o gráficos simples.\nMódulo de Relé: Controla dispositivos de mayor potencia, como luces o motores.\nPotenciómetro Ajustable: Permite variar la resistencia en los circuitos, ideal para calibraciones.\nConjunto de LED Multicolor: LEDs de diferentes colores para indicaciones visuales en tus proyectos.\nBotones de Prueba: Pulsadores para activar o desactivar funciones en los prototipos.\nZumbador Activo y Pasivo: Emite señales sonoras para notificaciones o alertas en los proyectos.\nResistencias Variadas: Conjunto de resistencias para el armado de diferentes tipos de circuitos.\nCable USB: Para conectar y programar el ESP32 desde tu computadora o laptop.\n¿Por qué elegir este kit?\nEste kit es perfecto para crear proyectos de automatización, IoT, domótica, medición ambiental y más. Incluye todo lo necesario para comenzar a aprender de manera práctica y divertida, con múltiples componentes que te permitirán realizar proyectos paso a paso.\n\nYa sea para mejorar tus habilidades en la programación de microcontroladores o para implementar tus propias ideas de automatización, este Kit de Inicio ESP32 con Sensores y Prototipos te ofrece un sinfín de posibilidades. ¡Empieza a crear hoy mismo!",
        "code": "",
        "datasheet": false
    },
    {
        "id": 149,
        "name": "RP2040 Zero de Raspberry Pi: La Mini Placa Ideal para Proyectos IoT",
        "price": "380",
        "quantity": 20,
        "images": [
            "Imagenes/149/149_1.jpg",
            "Imagenes/149/149_2.jpg",
            "Imagenes/149/149_3.jpg"
        ],
        "description": "RP2040 Zero de Raspberry Pi: La Mini Placa Potente para Proyectos IoT y Maker\n\nExplora todo tu potencial como maker con el RP2040 Zero, la última innovación de Raspberry Pi en un formato ultracompacto. Basada en el reconocido microcontrolador RP2040, esta placa es perfecta para proyectos de automatización, robótica, dispositivos portátiles y más. Diseñada para aquellos que buscan una solución potente y flexible en un tamaño reducido, el RP2040 Zero ofrece todo lo necesario para desarrollar aplicaciones IoT y prototipos avanzados sin comprometer el rendimiento.\n\nCaracterísticas destacadas:\nMicrocontrolador RP2040 de doble núcleo con frecuencia de hasta 133 MHz.\n2 MB de memoria flash para almacenar programas complejos.\n264 KB de SRAM, ideal para ejecutar múltiples procesos simultáneos.\n30 pines GPIO, incluyendo 3 entradas analógicas para una mayor conectividad.\nCompatible con MicroPython y C/C++, facilitando el desarrollo y la programación.\nFormato compacto: mide solo 22 x 18 mm, ideal para proyectos con limitaciones de espacio.\nConexión USB Tipo-C para una fácil programación y alimentación.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 151,
        "name": "Pantalla LCD 1.44'' SPI 128x128 TFT Color",
        "price": "390",
        "quantity": 15,
        "images": [
            "Imagenes/151/151_1.jpg",
            "Imagenes/151/151_2.jpg",
            "Imagenes/151/151_3.jpg"
        ],
        "description": "La pantalla LCD TFT de 1.44 pulgadas con interfaz SPI ofrece una resolución de 128x128 píxeles y colores vivos, ideal para proyectos de Arduino, Raspberry Pi y otros microcontroladores. Esta pantalla compacta es perfecta para aplicaciones de visualización de texto, gráficos y datos en tiempo real.\n\nEspecificaciones eléctricas:\nVoltaje de funcionamiento: 3.3 V o 5 V (compatibilidad con 5V mediante un regulador integrado).\nInterfaz de comunicación: SPI (Serial Peripheral Interface).\nResolución: 128 x 128 píxeles.\nTipo de pantalla: TFT LCD a color.\nControlador: ST7735 (compatible con bibliotecas gráficas populares).\nConsumo de corriente: 20-40 mA (dependiendo del brillo y el uso).\nTamaño:\nLargo: 43.5 mm\nAncho: 30 mm\nPines de conexión: VCC, GND, SCK, SDA, A0, RESET, CS, LED.\nVCC: Alimentación positiva.\nGND: Tierra.\nSCK: Señal de reloj SPI.\nSDA: Datos SPI.\nA0: Registro de dirección/selección de datos.\nRESET: Pin de reinicio.\nCS: Chip Select, para seleccionar la pantalla.\nLED: Control de retroiluminación de la pantalla.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 153,
        "name": "Sensor ENS160+ AHT21: Calidad de Aire + Temp/Hum",
        "price": "690",
        "quantity": 10,
        "images": [
            "Imagenes/153/153_1.jpg",
            "Imagenes/153/153_2.jpg",
            "Imagenes/153/153_3.jpg"
        ],
        "description": "El módulo ENS160+ AHT21 que ves en la imagen combina dos sensores para ofrecer un monitoreo detallado de la calidad del aire, temperatura y humedad. A continuación, te comparto sus detalles eléctricos:\n\n1. Alimentación:\nVoltaje de operación: 3.3V - 5V\nConsumo de corriente:\nENS160: aproximadamente 30 mA en operación activa.\nAHT21: aproximadamente 0.5 mA en medición, 0.01 mA en modo standby.\n2. Interfaces de comunicación:\nI2C (Inter-Integrated Circuit):\nPines: SDA (datos) y SCL (reloj).\nVelocidad: soporta hasta 400 kHz.\nDirecciones I2C:\nENS160: configurables, típicamente 0x53 u 0x52.\nAHT2x: 0x38.\nSPI (Serial Peripheral Interface) [opcional en ENS160]:\nPines: MISO, MOSI, SCK, CS.\n3. Características de los sensores:\nENS160 (Sensor de calidad de aire):\nMonitoreo de compuestos orgánicos volátiles (COVs) y dióxido de carbono equivalente (eCO₂).\nModos de operación: normal, bajo consumo y reposo.\nSensibilidad ajustable para diversas aplicaciones.\nAHT21 (Sensor de temperatura y humedad):\nRango de temperatura: -40°C a 85°C, precisión de ±0.3°C.\nRango de humedad: 0% a 100% RH, precisión de ±2% RH.\n4. Configuración de pines:\nVin: Entrada de alimentación (3.3V o 5V).\nGND: Tierra (referencia).\nSCL: Línea de reloj para I2C.\nSDA: Línea de datos para I2C.\nCS: Chip Select para SPI (cuando se usa).\nINT: Pin de interrupción para notificaciones.\n5. Compatibilidad:\nCompatible con microcontroladores como Arduino, ESP32, Raspberry Pi, etc.\nPuede integrarse fácilmente en sistemas IoT para monitoreo de aire en tiempo real.",
        "code": "#include <Wire.h>\n#include <Adafruit_AHTX0.h>\n#include <Adafruit_ENS160.h>\n\n// Instancia del sensor AHT2x\nAdafruit_AHTX0 aht;\n// Instancia del sensor ENS160\nAdafruit_ENS160 ens160;\n\nvoid setup() {\n  // Iniciar la comunicación serie\n  Serial.begin(115200);\n\n  // Iniciar la comunicación I2C\n  // Conexión I2C:\n  // Vin del módulo ENS160+AHT2x --> 3.3V del ESP32\n  // GND del módulo ENS160+AHT2x --> GND del ESP32\n  // SDA del módulo ENS160+AHT2x --> GPIO 21 del ESP32 (SDA)\n  // SCL del módulo ENS160+AHT2x --> GPIO 22 del ESP32 (SCL)\n  Wire.begin(21, 22);\n\n  // Inicializar el sensor AHT2x\n  if (!aht.begin()) {\n    Serial.println(\"No se pudo encontrar el sensor AHT2x. Verifique la conexión.\");\n    while (1);\n  } else {\n    Serial.println(\"Sensor AHT2x iniciado correctamente.\");\n  }\n\n  // Inicializar el sensor ENS160\n  if (!ens160.begin()) {\n    Serial.println(\"No se pudo encontrar el sensor ENS160. Verifique la conexión.\");\n    while (1);\n  } else {\n    Serial.println(\"Sensor ENS160 iniciado correctamente.\");\n  }\n}\n\nvoid loop() {\n  // Leer la temperatura y humedad del sensor AHT2x\n  sensors_event_t humidity, temp;\n  aht.getEvent(&humidity, &temp);\n  Serial.print(\"Temperatura: \");\n  Serial.print(temp.temperature);\n  Serial.println(\" °C\");\n  Serial.print(\"Humedad: \");\n  Serial.print(humidity.relative_humidity);\n  Serial.println(\" %\");\n\n  // Leer la calidad del aire del ENS160\n  ens160.setRHumidity((uint16_t)humidity.relative_humidity * 100); // Ajustar la humedad\n  ens160.setTemperature((int16_t)temp.temperature * 100); // Ajustar la temperatura\n\n  // Esperar a que el ENS160 esté listo para la lectura\n  delay(500); \n\n  // Mostrar datos del ENS160\n  Serial.print(\"TVOC (COV totales): \");\n  Serial.print(ens160.TVOC); \n  Serial.println(\" ppb\");\n\n  Serial.print(\"eCO2 (CO2 equivalente): \");\n  Serial.print(ens160.eCO2); \n  Serial.println(\" ppm\");\n\n  // Pausa de 2 segundos antes de la siguiente lectura\n  delay(2000);\n}",
        "datasheet": false
    },
    {
        "id": 155,
        "name": "Pack 2x IRFP264N MOSFETs: Potencia Máxima y Eficiencia",
        "price": "350",
        "quantity": 25,
        "images": [],
        "description": "especificaciones del IRFP264N:\nTipo: MOSFET de potencia, N-Channel\nVoltaje de drenaje-fuente (VDS): 250V\nCorriente de drenaje (ID): 47A (a 25°C)\nResistencia de encendido (RDS(on)): 0.075 ohmios (típico, a VGS = 10V)\nVoltaje de compuerta (VGS): ±20V (máximo)\nDisipación de potencia (PD): 300W (máximo)\nCapacidad de carga de compuerta (Ciss): 7300 pF\nEncapsulado: TO-247\nTemperatura de operación: -55°C a +175°C\nTiempo de conmutación:\nTiempo de encendido (ton): 38 ns (típico)\nTiempo de apagado (toff): 83 ns (típico)\nConfiguración de pines:\nDrenaje (Drain): Pin central y parte metálica del encapsulado\nFuente (Source): Pin derecho\nCompuerta (Gate): Pin izquierdo",
        "code": "",
        "datasheet": false
    },
    {
        "id": 157,
        "name": "Microcontrolador ESP32 C3 Mini Board con USB-C y WiFi/Bluetooth",
        "price": "450",
        "quantity": 20,
        "images": [
            "Imagenes/157/157_1.jpg",
            "Imagenes/157/157_2.jpg"
        ],
        "description": "Este módulo ESP32 C3 es una placa de desarrollo compacta y de bajo consumo, ideal para proyectos de IoT, automatización y electrónica. Incluye un puerto USB-C para una fácil programación y alimentación, dos botones (RESET y BOOT), y una serie de pines GPIO expuestos para conexión a sensores y periféricos. Basado en el chip ESP32-C3, ofrece conectividad WiFi y Bluetooth 5.0, soportando tanto BLE como Classic Bluetooth.\n\nEspecificaciones Eléctricas:\n\nVoltaje de entrada: 5V a través de USB-C.\nConsumo en modo inactivo: <10 μA en modo deep-sleep.\nPines GPIO disponibles: 21 pines con funciones múltiples (PWM, ADC, UART, I2C).\nConectividad: WiFi 2.4 GHz y Bluetooth 5.0.",
        "code": "#include <WiFi.h>\n#include <HTTPClient.h>\n#include <DHT.h>\n\n// Configuración del sensor DHT\n#define DHTPIN 4      // Pin GPIO al que está conectado el DHT\n#define DHTTYPE DHT22 // Modelo del sensor (DHT11 o DHT22)\nDHT dht(DHTPIN, DHTTYPE);\n\n// Configuración de WiFi\nconst char* ssid = \"TU_SSID\";\nconst char* password = \"TU_PASSWORD\";\n\n// URL del servidor donde se enviarán los datos\nconst char* serverName = \"http://tu-servidor.com/recibir_datos\";\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Inicia el sensor DHT\n  dht.begin();\n\n  // Conexión a WiFi\n  Serial.print(\"Conectando a WiFi...\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\nConectado a la red WiFi\");\n}\n\nvoid loop() {\n  if (WiFi.status() == WL_CONNECTED) {\n    HTTPClient http;\n\n    // Leer temperatura y humedad\n    float temperature = dht.readTemperature();\n    float humidity = dht.readHumidity();\n\n    // Verificar que la lectura es válida\n    if (isnan(temperature) || isnan(humidity)) {\n      Serial.println(\"Error al leer del sensor DHT!\");\n      return;\n    }\n\n    // Preparar la URL con los datos\n    String serverPath = serverName + String(\"?temp=\") + String(temperature) + \"&hum=\" + String(humidity);\n\n    // Iniciar conexión HTTP\n    http.begin(serverPath.c_str());\n\n    // Enviar solicitud GET\n    int httpResponseCode = http.GET();\n\n    // Procesar la respuesta del servidor\n    if (httpResponseCode > 0) {\n      String response = http.getString();\n      Serial.print(\"Código de respuesta: \");\n      Serial.println(httpResponseCode);\n      Serial.print(\"Respuesta del servidor: \");\n      Serial.println(response);\n    } else {\n      Serial.print(\"Error en la solicitud: \");\n      Serial.println(httpResponseCode);\n    }\n\n    // Cerrar conexión HTTP\n    http.end();\n  } else {\n    Serial.println(\"Desconectado de la red WiFi, intentando reconectar...\");\n    WiFi.reconnect();\n  }\n\n  // Esperar 10 segundos antes de la próxima lectura\n  delay(10000);\n}",
        "datasheet": false
    },
    {
        "id": 159,
        "name": "Módulo Cargador 18650 Tipo-C 5V 3A para 2 Pilas",
        "price": "450",
        "quantity": 10,
        "images": [
            "Imagenes/159/159_1.jpg",
            "Imagenes/159/159_2.jpg",
            "Imagenes/159/159_3.jpg"
        ],
        "description": "Este módulo de carga rápida está diseñado para alojar y cargar dos baterías de litio 18650 en paralelo, proporcionando una salida estable de 5V. Con una entrada tipo C y una corriente de salida de hasta 3A, es ideal para alimentar dispositivos portátiles y otros proyectos electrónicos que requieren una fuente de energía confiable y de alta eficiencia. La configuración de dos pilas permite una mayor capacidad de almacenamiento de energía, ofreciendo una solución compacta y práctica para proyectos portátiles.\n\nEspecificaciones eléctricas:\n\nEntrada: Puerto USB tipo C\nSalida: 5V estable\nCorriente de salida: Hasta 3A\nCompatibilidad de batería: Litio 18650 (2 pilas)\nProtecciones: Contra sobrecarga, cortocircuito y sobrecalentamiento",
        "code": "",
        "datasheet": false
    },
    {
        "id": 161,
        "name": "Adaptador USB a RS485 Serial, Comunicación Estable",
        "price": "290",
        "quantity": 10,
        "images": [
            "Imagenes/161/161_1.jpg",
            "Imagenes/161/161_2.jpg",
            "Imagenes/161/161_3.jpg",
            "Imagenes/161/161_4.jpg",
            "Imagenes/161/161_5.jpg"
        ],
        "description": "Este adaptador USB a RS485 permite la conversión directa entre un puerto USB de una computadora y un bus RS485. Es una solución ideal para proyectos de control industrial y comunicación de larga distancia. La conexión se realiza fácilmente a través del puerto USB y ofrece una comunicación confiable y estable en entornos industriales.\n\nEspecificaciones eléctricas:\n\nEntrada: USB (5V) desde la computadora o dispositivo host\nSalida: RS485, con terminal de tornillo para conexión de cables\nVoltaje de operación: Alimentado por USB (5V)\nChipset: Típicamente basado en CH340 o similar (verificar en la especificación específica del fabricante)\nProtección: Contra interferencias eléctricas y electrostáticas",
        "code": "",
        "datasheet": false
    },
    {
        "id": 163,
        "name": "Reloj DS3231 RTC con EEPROM AT24C32 para Arduino y ESP32",
        "price": "210",
        "quantity": 30,
        "images": [
            "Imagenes/163/163_1.jpg",
            "Imagenes/163/163_2.jpg",
            "Imagenes/163/163_3.jpg",
            "Imagenes/163/163_4.jpg",
            "Imagenes/163/163_5.jpg"
        ],
        "description": "El módulo DS3231 es un reloj de tiempo real (RTC) de alta precisión con compensación de temperatura, que mantiene la hora y fecha exacta bajo diversas condiciones de temperatura. Funciona mediante comunicación I2C y proporciona salidas para segundos y alarma programable. Incluye una memoria EEPROM AT24C32 de 32Kbits (4KB) también compatible con I2C, que permite almacenar configuraciones y datos. Requiere una pila CR2032 para mantener la hora cuando no está conectado a la alimentación. Sus pines VCC y GND alimentan el módulo, mientras que los pines SDA y SCL se conectan al microcontrolador.",
        "code": "#include <Wire.h>\n#include <RTClib.h>\n\nRTC_DS3231 rtc;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();  // Inicia I2C para ESP32 (usa SDA y SCL estándar de ESP32)\n  \n  if (!rtc.begin()) {\n    Serial.println(\"No se pudo encontrar el DS3231.\");\n    while (1);\n  }\n\n  if (rtc.lostPower()) {\n    Serial.println(\"El reloj no está ajustado, estableciendo fecha y hora.\");\n    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // Ajusta al tiempo de compilación\n  }\n}\n\nvoid loop() {\n  DateTime now = rtc.now();\n  \n  Serial.print(\"Fecha: \");\n  Serial.print(now.year(), DEC);\n  Serial.print('/');\n  Serial.print(now.month(), DEC);\n  Serial.print('/');\n  Serial.print(now.day(), DEC);\n  Serial.print(\" Hora: \");\n  Serial.print(now.hour(), DEC);\n  Serial.print(':');\n  Serial.print(now.minute(), DEC);\n  Serial.print(':');\n  Serial.print(now.second(), DEC);\n  Serial.println();\n\n  delay(1000);  // Espera 1 segundo antes de actualizar\n}",
        "datasheet": false
    },
    {
        "id": 165,
        "name": "Placa PCB FR4 7x10cm Cobre Un Lado",
        "price": "180",
        "quantity": 20,
        "images": [
            "Imagenes/165/165_1.jpg",
            "Imagenes/165/165_2.jpg",
            "Imagenes/165/165_3.jpg"
        ],
        "description": "Placa de circuito impreso FR4 de 7x10 cm con laminado de cobre de un solo lado, ideal para proyectos DIY y prototipos. Fabricada en material FR4 de alta calidad, permite realizar conexiones y circuitos personalizados con facilidad. Perfecta para diseñadores electrónicos y entusiastas del bricolaje en electrónica.",
        "code": "",
        "datasheet": false
    },
    {
        "id": 167,
        "name": "Generador PWM Dual con Pantalla LCD",
        "price": "340",
        "quantity": 10,
        "images": [
            "Imagenes/167/167_1.jpg",
            "Imagenes/167/167_2.jpg",
            "Imagenes/167/167_3.jpg",
            "Imagenes/167/167_4.jpg"
        ],
        "description": "El módulo XY-LPWM es un generador de señal PWM compacto y de alta precisión, diseñado para controlar dispositivos electrónicos como motores, LED y circuitos de modulación.\nCaracterísticas técnicas:\n\nAlimentación: 3.3V–30V DC (entrada Micro USB o terminales de tornillo).\nFrecuencia de salida: 1Hz–150kHz.\nResolución:\n1Hz para frecuencias de 1–999Hz.\n0.1kHz para frecuencias de 1.0–99.9kHz.\n1kHz para frecuencias de 100kHz–150kHz.\nDuty cycle (ciclo de trabajo): 0% a 100%, ajustable en incrementos de 1%.\nCorriente de salida: <30mA.\nAmplitud de señal: 5Vp-p (ajustable mediante el potenciómetro).\nInterfaz de control: Botones físicos y comunicación serial (9600bps).\nDimensiones: Compacto, fácil de integrar en cualquier proyecto.",
        "code": "#include <HardwareSerial.h>\n\nHardwareSerial mySerial(1); // UART1 en ESP32 (pines configurables)\n\nvoid setup() {\n  Serial.begin(115200); // Monitor serial\n  mySerial.begin(9600, SERIAL_8N1, 16, 17); // UART1: RX=16, TX=17\n\n  // Configuración inicial del PWM\n  setPWMFrequency(1, 1000);  // PWM1: 1 kHz\n  setPWMDutyCycle(1, 50);    // PWM1: 50% duty cycle\n  setPWMFrequency(2, 2000);  // PWM2: 2 kHz\n  setPWMDutyCycle(2, 75);    // PWM2: 75% duty cycle\n}\n\nvoid loop() {\n  // Aquí puedes agregar lógica para ajustar parámetros dinámicamente\n}\n\n// Función para configurar frecuencia de PWM\nvoid setPWMFrequency(uint8_t channel, float frequency) {\n  String command = \"S\" + String(channel) + \"F\" + String(frequency, 1) + \"T\";\n  sendCommand(command);\n}\n\n// Función para configurar ciclo de trabajo (duty cycle)\nvoid setPWMDutyCycle(uint8_t channel, uint8_t dutyCycle) {\n  String command = \"S\" + String(channel) + \"D\" + String(dutyCycle) + \"T\";\n  sendCommand(command);\n}\n\n// Función para enviar comandos al módulo\nvoid sendCommand(String command) {\n  mySerial.print(command);   // Enviar comando\n  delay(50);                 // Esperar respuesta\n  while (mySerial.available()) {\n    String response = mySerial.readString();\n    Serial.println(\"Respuesta: \" + response); // Mostrar respuesta\n  }\n}",
        "datasheet": false
    }
]